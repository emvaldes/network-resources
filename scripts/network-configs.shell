#!/usr/bin/env bash

## -------------------------------------------------------------------------- ##
## File: scripts/network-configs.shell
##
## Purpose:
##   Top-level dispatcher for pre-processing multi-vendor network configurations.
##   Extracts relevant sections (e.g., ACLs, objects, addresses) based on a
##   user-defined search pattern (typically IP addresses), reducing massive
##   configuration files into targeted, minimal artifacts for faster analysis.
##
## Description:
##   - Accepts a direct config file (--config), specific filenames (--search),
##     or a full directory scan (--location), with conditional prompting if needed.
##   - Automatically detects vendor platform (Cisco, Fortinet).
##   - Delegates extraction to `extract-configs.shell` for platform-specific handling.
##   - Matching logic filters input configs to only those containing the pattern.
##   - Output files are stored using preserved directory structure under --output
##     or default location `./resources/` if not provided.
##
## Input Prioritization:
##   - Priority: --location > --search > --config
##   - If --config is omitted and --search is used, --location is required.
##   - If neither --config nor --search is provided, --location will be prompted.
##
## Extraction Logic:
##   - Fortinet: matches ‘fortinet’, ‘fortigate’
##   - Cisco: matches ‘asa’, ‘interface’, ‘object’, ‘cisco ios’
##
## Usage:
##   bash ./scripts/network-configs.shell \
##     --ip-addr=198.51.100.75 \
##     --config=./configs/device.cfg \
##     --output=./results/device-reduced.cfg \
##     --verbose ;
##
## Exit Codes: Please, check built-in help (--help) for details
##
## -------------------------------------------------------------------------- ##

set -euo pipefail  ## Strict mode: exit on error, undefined var use, and pipeline failure
# set -x;          ## Enable for execution tracing/debugging

## POSIX locale standard
export LC_ALL=C   ## Ensure consistent sorting and character handling (POSIX-compliant)

# Create a secure, temporary working directory (auto-cleaned at script exit)
export TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

export nl="\n";

#------------------------------------------------------------------------------#
function display_help () {

    local -a help_lines=();
    local indent="    ";
    local padding="$( printf '%*s' ${#script_name} ' ' )";
    ## Header
    help_lines+=( "Usage: ${script_name} [OPTIONS]${nl}" );
    ## Available Operational Requests
    help_lines+=( "Options:${nl}" );
    help_lines+=( "  -i, --ip-addr      Custom Search Pattern: IP Address, etc." );
    help_lines+=( "  -c, --config       Single (target) Configuration filepath to be parsed" );
    help_lines+=( "  -s, --search       Configurations listing to be located (files: {abc,def,ghi}.cfg)" );
    help_lines+=( "  -l, --location     Requires to listing all files matching a criteria (files: *.cfg)" );
    help_lines+=( "  -o, --output       Output Filepath for extracted datasets (*.cfg)${nl}" );
    ## Default Application Flags
    help_lines+=( "Flags:${nl}" );
    help_lines+=( "  --help             Show this help message and exit" );
    # help_lines+=( "  --debug            Enable debug mode with trace output" );
    # help_lines+=( "  --dry-run          Print actions without executing them" );
    help_lines+=( "  --verbose          Enable verbose output${nl}" );
    ## Exit Codes Details
    help_lines+=( "Exit Codes:${nl}" );
    help_lines+=( "   1 = Missing or empty search pattern:" );
    help_lines+=( "       Triggered if --ip-addr is not provided or input is blank when prompted.${nl}" );
    help_lines+=( "   2 = No valid configuration file(s) found and raised when:${nl}" );
    help_lines+=( "       a) --config is given but the file does not exist." );
    help_lines+=( "       b) --location scan yields no matching files." );
    help_lines+=( "       c) Fallback user prompt yields an invalid config file.${nl}" );
    help_lines+=( "   3 = Unsupported configuration format:" );
    help_lines+=( "       The config file exists but doesn't match any known vendor pattern.${nl}" );
    help_lines+=( "   4 = Unrecognized configuration content:" );
    help_lines+=( "       Generic catch-all for unexpected detection behavior (should rarely trigger).${nl}" );
    help_lines+=( "   5 = Output path creation failed:" );
    help_lines+=( "       Raised if the output directory cannot be created (e.g., permissions error).${nl}" );
    help_lines+=( "   6 = Invalid --location directory:" );
    help_lines+=( "       Raised if user provides an invalid directory when prompted for --location.${nl}" );
    help_lines+=( "   7 = No config files matched --search list:" );
    help_lines+=( "       All filenames in --search failed to resolve under the provided --location.${nl}" );
    help_lines+=( "   8 = Unsafe or ambiguous output directory path:" );
    help_lines+=( "       Refuses to operate if target is root (/), current (./), or empty path.${nl}" );
    help_lines+=( "   9 = mkdir failure:" );
    help_lines+=( "       Raised if directory creation for the output path fails.${nl}" );
    help_lines+=( "  10 = rm -rf failure:" );
    help_lines+=( "       Raised if the script fails to clean out the existing output directory.${nl}" );
    help_lines+=( "  11 = Source config resides or overlaps in output path:" );
    help_lines+=( "       Raised if the source configuration file is located inside the output directory, risking overwrite.${nl}" );
    ## Application Notes
    help_lines+=( "Application Notes:${nl}" );
    help_lines+=( "  * All search patterns may be individual, comma-separated, or CIDR-based." );
    help_lines+=( "  * Option: --output flag is optional; defaults to '${output_config}'." );
    help_lines+=( "  * Option: --location is required if using --search or scanning full directory.${nl}" );
    ## Application Examples
    help_lines+=( "Examples:${nl}" );
    help_lines+=( "  1. Extract entries referencing a known IP:" );
    help_lines+=( "     bash ${script_name} \\" );
    help_lines+=( "          --ip-addr=\"198.51.100.75\" \\" );
    help_lines+=( "          --config=configs/cisco/branch-isr-02.cfg \\" );
    help_lines+=( "          --output=tmp/branch-isr-02-reduced.cfg \\" );
    help_lines+=( "          --verbose${nl}" );
    help_lines+=( "  2. Match multiple IP addresses in a single pass:" );
    help_lines+=( "     bash ${script_name} \\" );
    help_lines+=( "          --ip-addr=\"10.0.2.3,172.16.1.6\" \\" );
    help_lines+=( "          --config=configs/cisco/branch-isr-02.cfg \\" );
    help_lines+=( "          --output=tmp/branch-isr-02-multi.cfg \\" );
    help_lines+=( "          --verbose${nl}" );
    help_lines+=( "  3. Extract entries from multiple config files by name (search + location):" );
    help_lines+=( "     bash ${script_name} \\" );
    help_lines+=( "          --ip-addr=\"198.51.100.75,203.0.113.10,10.0.0.1\" \\" );
    help_lines+=( "          --search=\"branch-isr-02.cfg,fg-lab-test-fw.cfg\" \\" );
    help_lines+=( "          --location=./configs \\" );
    help_lines+=( "          --output=tmp/multi-config-search \\" );
    help_lines+=( "          --verbose${nl}" );
    help_lines+=( "  4. Match multiple IPs across all config files in a folder (directory scan):" );
    help_lines+=( "     bash ${script_name} \\" );
    help_lines+=( "          --ip-addr=\"192.168.1.10,203.0.113.25,10.0.2.3\" \\" );
    help_lines+=( "          --location=./configs \\" );
    help_lines+=( "          --output=tmp/folder-scan \\" );
    help_lines+=( "          --verbose${nl}" );
    help_lines+=( "  5. Match multiple IPs when config files are unknown (full scan with auto output):" );
    help_lines+=( "     bash ${script_name} \\" );
    help_lines+=( "          --ip-addr=\"10.0.0.1,198.51.100.75,203.0.113.25\" \\" );
    help_lines+=( "          --location=./configs \\" );
    help_lines+=( "          --verbose${nl}" );
    ## Display Built-In Help
    newline;
    for line in "${help_lines[@]}"; do
      message "${indent}${line}";
    done;

    return 0;
}; alias display-help='display_help';

#------------------------------------------------------------------------------#
## Output Utilities: Print N newlines (default: 1)
function newline () {
    local count="${1:-1}";
    for ((i = 0; i < count; i++)); do echo; done;
    # return 0;
  }; alias new-line='newline';

#------------------------------------------------------------------------------#
## Output Utilities: Print an error message in consistent format
function message () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -e "${message}";
    # return 0;
  }; alias print-message='message';

#------------------------------------------------------------------------------#
function detect_vendor () {
    local config_file="${1}";
    local fortinet_pattern='fortinet|fortigate';
    local cisco_pattern='\basa\b|cisco ios|cisco adaptive|^interface\b|^object\b';
    if grep -qiE "${fortinet_pattern}" "${config_file}"; then
            return 1;
      elif  grep -qiE "${cisco_pattern}" "${config_file}" 2>/dev/null; then
            return 2;
      else  return 3;
    fi;
    return 0;
}; alias detect-vendor='detect_vendor';

#------------------------------------------------------------------------------#
function main () {
    ## tracking_process ${FUNCNAME} "${@}";
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(ip-addr|i)$ ]] && local search_pattern="${value}";
      [[ $key =~ ^(config|c)$ ]] && local source_config="${value}";
      [[ $key =~ ^(search|s)$ ]] && local search_configs="${value}";
      [[ $key =~ ^(location|l)$ ]] && local search_location="${value}";
      [[ $key =~ ^(output|o)$ ]] && local output_config="${value}";

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && local debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true;
    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied

    [[ -z ${script_helper:-} ]] && local script_helper=false;
    [[ -z "${output_config:-}" ]] && export output_config="./resources";

    [[ -z ${debug:-} ]] && debug=false;
    [[ -z ${dry_run:-} ]] && dry_run=false;
    [[ -z ${verbose:-} ]] && verbose=false;

    #### -----------------------------------------------------------------------
    ## Display usage help if requested
    if [[ ${script_helper:-} == true ]]; then
      display_help;
      exit 0;
    fi;

    #### -----------------------------------------------------------------------
    declare -a configs_listing=();
    local action_class="unknown";

    #### -----------------------------------------------------------------------
    ## Parameter: --config → lowest precedence (single file)
    if [[ -n "${source_config:-}" && -f "${source_config}" ]]; then
      configs_listing=( "${source_config}" );
      action_class="config";
    fi;

    #### -----------------------------------------------------------------------
    ## Resolve or request --location if required by absence of --config or --search
    if [[ -z "${search_location:-}" ]]; then
      if { [[ -n "${search_configs:-}" ]] && [[ -z "${source_config:-}" ]]; } || \
        { [[ -z "${search_configs:-}" ]] && [[ -z "${source_config:-}" ]]; }; then
        newline;
        read -e -p "Enter base directory to search for configs [--location]: " search_location;
        search_location="${search_location:-.}";
        if [[ ! -d "${search_location}" ]]; then
          message "Error: Provided --location '${search_location}' is not a valid directory." >&2;
          newline;
          exit 1;
        fi;
      fi;
    fi;

    #### -----------------------------------------------------------------------
    while [[ -z ${search_pattern:-} ]]; do
      newline;
      read -e -p "Enter target search pattern: " search_pattern
      if [[ "${search_pattern:-}" =~ ^[[:space:]]*$ ]]; then
        message "Warning: Pattern cannot be empty!" >&2;
        newline;
        exit 2;
      fi;
    done;

    #### -----------------------------------------------------------------------
    ## Parameter: --search → overrides --config (comma-separated list, needs lookup)
    if [[ -n "${search_configs:-}" ]]; then
      IFS=',' read -r -a search_items <<< "${search_configs}";
      declare -a found_configs=();
      for item in "${search_items[@]}"; do
        result="$(
          find "${search_location}" -type f -name "${item}" 2>/dev/null
        )";
        [[ -n "$result" ]] && found_configs+=( "${result}" );
      done;
      [[ "${#found_configs[@]}" -gt 0 ]] && \
          configs_listing=( "${found_configs[@]}" );
      action_class="search";
    fi;

    #### -----------------------------------------------------------------------
    ## If no configs resolved yet and --location is valid → fallback full scan
    if [[ "${#configs_listing[@]}" -eq 0 && \
          -n "${search_location:-}" && \
          -d "${search_location}" 
        ]]; then
      mapfile -t configs_listing < <(
        find "${search_location}" -type f -name "*.cfg" 2>/dev/null
      );
      if [[ "${#configs_listing[@]}" -eq 0 ]]; then
        message "No configuration files found under location: ${search_location}";
        newline;
        exit 3;
      fi;
      if [[ "${#configs_listing[@]}" -gt 0 && \
            -n "${search_location:-}" && \
            -z "${search_configs:-}" && \
            -z "${source_config:-}" ]]; then
        action_class="location";
      fi;
    fi;

    if [[ -n "${search_configs:-}" || -n "${search_location:-}" ]]; then

      #### ---------------------------------------------------------------------
      ## Show which configs actually match the IP pattern
      declare -a matched_configs=();
      IFS=',' read -ra ip_list <<< "${search_pattern}";
      for cfg in "${configs_listing[@]}"; do
        for ip in "${ip_list[@]}"; do
          if grep -qF "${ip}" "${cfg}"; then
            matched_configs+=( "${cfg}" );
            break;
          fi;
        done;
      done;

      #### ---------------------------------------------------------------------
      if [[ "${#matched_configs[@]}" -gt 0 ]]; then
              message "Matching IPs found in ${#matched_configs[@]} files:";
              newline;
              for item in "${matched_configs[@]}"; do
                message "  - ${item}";
              done;
              newline;
              configs_listing=( "${matched_configs[@]}" );
        else  message "No matches for search pattern '${search_pattern}' in ${search_location:-search scope}";
              newline;
              exit 4;
      fi;

    fi;

    #### -----------------------------------------------------------------------
    ## Fallback prompt if all failed
    if [[ "${#configs_listing[@]}" -eq 0 ]]; then
      newline;
      read -e -p "Enter source configuration file: " source_config;
      if [[ -f "${source_config}" ]]; then
              configs_listing=( "${source_config}" );
        else  message "Error: No valid configuration file provided or found." >&2;
              newline;
              exit 5;
      fi;
    fi;

    #### -----------------------------------------------------------------------
    # Loop through configs_listing array
    for source_config in "${configs_listing[@]}"; do
      [[ ! -f "${source_config}" ]] && continue;

      #### -----------------------------------------------------------------------
      set +e;
      detect_vendor "${source_config}";
      local vendor_code=${?};
      # message "Vendor Code: ${vendor_code}";
      set -e;
      case "${vendor_code}" in
        1)  target_platform="fortinet";
            ;;
        2)  target_platform="cisco";
            ;;
        3)  message "Unsupported configuration type: ${source_config}";
            newline 2;
            exit 6;
            ;;
        *)  message "Unknown configuration type: ${source_config}";
            newline 2;
            exit 7;
            ;;
      esac;

      message "Parsing [ ${target_platform} ] configs (by: ${action_class}): ";
      #### -----------------------------------------------------------------------
      if [[ -n "${output_config:-}" ]]; then
              base_output="${output_config%/}";
              rel_path="$(
                echo "${source_config}" | sed 's|^\./||'
              )";
              target_output="${base_output}/${rel_path}";
        else  config_filename="$(
                basename "${source_config}"
              )";
              target_output="$( pwd )/${target_platform}--${config_filename}";
      fi;
      message "Target Output: [ ${target_output} ]";

      #### -----------------------------------------------------------------------
      local output_dir="$(
        dirname "${target_output}"
      )";
      message "Output Directory: [ ${output_dir} ]";

      #### -----------------------------------------------------------------------
      ## Safety check — always validate path BEFORE any mkdir or rm -rf
      if [[ "${output_dir}" =~ ^(/|\./?$|)$ ]]; then
        message "Error: Refusing to operate on unsafe or ambiguous output directory: '${output_dir}'" >&2;
        newline;
        exit 8;
      fi;

      #### -----------------------------------------------------------------------
      ## Ensure output directory exists or create it
      if [[ ! -d "${output_dir}" ]]; then
              mkdir -p "${output_dir}" || {
                message "Warning: Failed to create output directory: ${output_dir}" >&2;
                newline;
                exit 9;
              };
        else  rm -rf "${output_dir:?}/"* || {
                message "Warning: Failed to clear output directory: ${output_dir}" >&2;
                newline;
                exit 10;
              };
      fi;

      #### -----------------------------------------------------------------------
      ## Prevent source files from residing within the output directory
      if [[ -L "${source_config}" || \
            -L "${output_config}" || \
            "${source_config}" == "${output_config}"*
          ]]; then
        message "Error: Unsafe configuration — symlinks detected or Source/Output paths are overlaping!" >&2;
        newline;
        exit 11;
      fi;

      #### -----------------------------------------------------------------------
      declare -a execute=(
        ./scripts/extract-configs.shell
        --ip-addr="${search_pattern}"
        --config="${source_config}"
        --output="${target_output}"
      );
      [[ "${verbose}" == true ]] && execute+=( --verbose );

      #### -----------------------------------------------------------------------
      ## Execute and propagate exit status
      $( which bash ) "${execute[@]}" >/dev/null 2>&1;

      if [[ "${verbose}" == true ]]; then
        message "Configuration File [ ${target_output} ]";
        newline;
        cat -n "${target_output}";
        newline;
      fi;

    done;

    tree "${output_config}";
    newline;

    return 0;
}; alias parse-cisco='main';

[[ -z "${script_name+x}" ]] && export script_name="${0}";

#------------------------------------------------------------------------------#

if [[ ${#@} -ge 1 && "${1,,}" =~ ^-*(h|help)$ ]]; then
        main --help ;
  else  newline;
        main "${@}";
        result=${?}; exit ${result};
        ## newline; message "Done."; newline;
fi;

## -------------------------------------------------------------------------- ##
## Examples: Please, check built-in help (--help) for details
## -------------------------------------------------------------------------- ##
