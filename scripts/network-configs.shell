#!/usr/bin/env bash

## -------------------------------------------------------------------------- ##
## File: scripts/network-configs.shell
##
## Purpose:
##   Top-level dispatcher for pre-processing multi-vendor network configurations.
##   Extracts relevant sections (e.g., ACLs, objects, addresses) based on a
##   user-defined search pattern (typically IP addresses), reducing massive
##   configuration files into targeted, minimal artifacts for faster analysis.
##
## Description:
##   - Accepts a list of IPs (--configs), device names (--search), or a full
##     directory scan (--location). Prompts interactively if missing.
##   - Automatically detects platform type (Cisco, Fortinet, or unknown).
##   - Delegates to `extract-configs.shell` for vendor-specific reduction.
##   - Only configuration files containing matching IPs are extracted.
##   - Extracted outputs mirror the original structure under the --extract path
##     or default to `./resources/` if unspecified.
##
## Input Prioritization:
##   - Priority: --location is required when using --search or --configs
##   - --search: filters device names/patterns inside the --location directory
##   - --configs: list of IPs to search (file or inline)
##
## Extraction Logic:
##   - Cisco: matches 'interface', 'object', 'access-list', etc.
##   - Fortinet: matches 'config', 'edit', 'next', 'end'
##   - Unrecognized configs are skipped with a warning.
##
## Usage:
##   bash ./scripts/network-configs.shell \
##     --search=devices.list \
##     --configs=ips.list \
##     --location=./configs \
##     --extract=.cache/resources \
##     --verbose
##
## Exit Codes:
##   Use --help to display detailed exit code descriptions.
##
## -------------------------------------------------------------------------- ##

set -euo pipefail  ## Strict mode: exit on error, undefined var use, and pipeline failure
# set -x;          ## Enable for execution tracing/debugging

## POSIX locale standard
export LC_ALL=C   ## Ensure consistent sorting and character handling (POSIX-compliant)

# Create a secure, temporary working directory (auto-cleaned at script exit)
export TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

export nl="\n";

#------------------------------------------------------------------------------#
function display_help () {

    local -a help_lines=();
    local indent="    ";
    local padding="$( printf '%*s' ${#script_name} ' ' )";
    ## Header
    help_lines+=( "Usage: ${script_name} [OPTIONS]${nl}" );
    ## Available Operational Requests
    help_lines+=( "Options:${nl}" );
    help_lines+=( "  -s, --search       List of device names or patterns to include in config filtering" );
    help_lines+=( "  -c, --configs      File containing configuration paths to evaluate (output of discovery)" );
    help_lines+=( "  -l, --location     Root directory to scan for configs (required with --search)" );
    help_lines+=( "  -o, --extract      Destination directory for extracted config subsets (default: .cache/resources)${nl}" );
    ## Default Application Flags
    help_lines+=( "Flags:${nl}" );
    help_lines+=( "  --help             Show this help message and exit" );
    help_lines+=( "  --verbose          Enable verbose output${nl}" );
    ## Exit Codes Details
    help_lines+=( "Exit Codes:${nl}" );
    help_lines+=( "   4 = Failed to create cache directory (e.g., permissions error)${nl}" );
    help_lines+=( "   5 = Invalid or unreadable --location directory provided${nl}" );
    help_lines+=( "   6 = No IPs or configs matched during evaluation${nl}" );
    help_lines+=( "   7 = Failed to write matching IPs to .cache/ips.list${nl}" );
    help_lines+=( "   8 = No valid IPs found — skipped writing .cache/ips.list${nl}" );
    help_lines+=( "   9 = Failed to write matched config paths to .cache/configs.list${nl}" );
    help_lines+=( "  10 = No valid configs found — skipped writing .cache/configs.list${nl}" );
    help_lines+=( "  11 = Unsupported configuration format detected in a source file${nl}" );
    help_lines+=( "  12 = Unknown configuration type — vendor detection failed${nl}" );
    ## Application Notes
    help_lines+=( "Application Notes:${nl}" );
    help_lines+=( "  * All search patterns may be individual, comma-separated, or wildcard-based." );
    help_lines+=( "  * Option: --extract is the preferred output directory override." );
    help_lines+=( "  * Option: --location is required when filtering configs by name or scope.${nl}" );
    ## Application Examples
    help_lines+=( "Examples:${nl}" );
    help_lines+=( "  1. Reduce a known configuration file against a list of IPs:" );
    help_lines+=( "     bash ${script_name} \\" );
    help_lines+=( "          --search=ips.list \\" );
    help_lines+=( "          --configs=devices.list \\" );
    help_lines+=( "          --location=./configs \\" );
    help_lines+=( "          --extract=.cache/resources \\" );
    help_lines+=( "          --verbose${nl}" );
    help_lines+=( "  2. Run a full scan across all configs in a folder for a batch of IPs:" );
    help_lines+=( "     bash ${script_name} \\" );
    help_lines+=( "          --search=ips.list \\" );
    help_lines+=( "          --location=./configs \\" );
    help_lines+=( "          --extract=./reduced \\" );
    help_lines+=( "          --verbose${nl}" );
    ## Display Built-In Help
    newline;
    for line in "${help_lines[@]}"; do
      message "${indent}${line}";
    done;

    return 0;
}; alias display-help='display_help';

#------------------------------------------------------------------------------#
## Output Utilities: Print N newlines (default: 1)
function newline () {
    local count="${1:-1}";
    for ((i = 0; i < count; i++)); do echo; done;
    # return 0;
  }; alias new-line='newline';

#------------------------------------------------------------------------------#
## Output Utilities: Print message in consistent format
function message () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -e "${message}";
    # return 0;
  }; alias print-message='message';

#------------------------------------------------------------------------------#
## Output Utilities: Print a message (no-newline) in consistent format
function print () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -en "${message}";
    # return 0;
  }; alias print-inline='print';

#------------------------------------------------------------------------------#
## Output Utilities: Print an error message in consistent format
function warning () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -e "Warning: ${message}";
    # return 0;
}; alias error-message='warning';

#------------------------------------------------------------------------------#
function detect_vendor () {
    local config_file="${1}";
    local fortinet_pattern='fortinet|fortigate';
    local cisco_pattern='\basa\b|cisco ios|cisco adaptive|^interface\b|^object\b';
    if grep -qiE "${fortinet_pattern}" "${config_file}"; then
            return 1;
      elif  grep -qiE "${cisco_pattern}" "${config_file}" 2>/dev/null; then
            return 2;
      else  return 3;
    fi;
    # return 0;
}; alias detect-vendor='detect_vendor';

#------------------------------------------------------------------------------#
function main () {
    ## tracking_process ${FUNCNAME} "${@}";
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(search|s)$ ]] && local search_pattern="${value}";
      [[ $key =~ ^(configs|c)$ ]] && local search_configs="${value}";
      [[ $key =~ ^(location|l)$ ]] && local search_location="${value}";
      [[ $key =~ ^(extract|x)$ ]] && local extract_location="${value}";
      [[ $key =~ ^(cache|e)$ ]] && local cache_location="${value}";

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && local debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true;
    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied
    [[ -z ${debug:-} ]] && debug=false;
    [[ -z ${dry_run:-} ]] && dry_run=false;
    [[ -z ${verbose:-} ]] && verbose=false;

    #### -----------------------------------------------------------------------
    [[ -z "${search_pattern:-}" ]] && export search_pattern=;
    [[ -z "${search_configs:-}" ]] && export search_configs=;
    [[ -z "${search_location:-}" ]] && export search_location=;
    [[ -z "${cache_location:-}" ]] && export cache_location="./.cache";
    [[ -z "${extract_location:-}" ]] && export extract_location="./resources";

    #### -----------------------------------------------------------------------
    ## Display usage help if requested
    [[ -z ${script_helper:-} ]] && local script_helper=false;
    if [[ ${script_helper:-} == true ]]; then
      display_help;
      exit 0;
    fi;

    #### -----------------------------------------------------------------------
    ## Persist filtered IPs to .cache/ips.list (only) — never modify the ./ips.list
    mkdir -p "${cache_location}" 2>/dev/null || {
      warning "Failed to create ${cache_location} directory.";
      return 4;
    };

    #### -----------------------------------------------------------------------
    ## Application's cache-related components
    export active_ips_file="${cache_location}/ips.list";
    export active_configs_file="${cache_location}/configs.list";

    # Always reset before use to avoid stale data
    : > "${active_ips_file}" 2>/dev/null || rm -f "${active_ips_file}" 2>/dev/null;
    : > "${active_configs_file}" 2>/dev/null || rm -f "${active_configs_file}" 2>/dev/null;

    #### -----------------------------------------------------------------------
    ## Prompt for search pattern if not provided
    local prompt_message="Enter search pattern (IP address, CIDR, etc.): ";
    while [[ -z "${search_pattern}" ]]; do
      newline;
      read -e -p "${prompt_message}" search_pattern;
      if [[ "${search_pattern// /}" == "" ]]; then
        warning "Search pattern is required.";
        search_pattern=false;
        return 1;
      fi;
    done;

    #### -----------------------------------------------------------------------
    ## Normalize search pattern input into search_terms[]
    declare -a search_terms=();

    if [[ -f "${search_pattern}" && "${search_pattern}" != *,* ]]; then
            ## Read IPs from file
            mapfile -t search_terms < <(
              tr -d '\r' < "${search_pattern}" | \
              grep -v '^\s*$' | grep -v '^#'
            );
      else  ## Inline string — preserve full IPs and split only on clear delimiters
            IFS=$'\n' read -r -d '' -a search_terms <<< "$(
              echo "${search_pattern}" | \
              sed 's/[][|;:]/ /g' | tr ', ' '\n\n' | \
              grep -v '^\s*$'
            )" || true;
            ## Write to temp file
            search_pattern="${TMP_DIR}/ips.list";
            printf "%s\n" "${search_terms[@]}" > "${search_pattern}";
    fi;

    #### -----------------------------------------------------------------------
    ## Prompt for source configuration files if not provided
    local prompt_message="Enter configuration file(s) or search path (comma-separated): ";
    while [[ -z "${search_configs}" && -z "${search_location}" ]]; do
      newline;
      read -e -p "${prompt_message}" search_configs;
      if [[ "${search_configs// /}" == "" ]]; then
        warning "Either --configs or --location must be provided.";
        search_configs="";
        continue;
      fi;
      # Check if it's a single file (no commas), and verify it exists and is readable
      if [[ "${search_configs}" != *,* ]]; then
        if [[ ! -f "${search_configs}" || ! -r "${search_configs}" ]]; then
          warning "Provided file [ ${search_configs} ] does not exist or is not readable.";
          search_configs="";
          continue;
        fi;
      fi;
    done;

    #### -----------------------------------------------------------------------
    ## Prompt for search location if not provided
    local prompt_message="Enter base directory to search configuration files: ";
    while [[ -z "${search_location}" ]]; do
      newline;
      read -e -p "${prompt_message}" search_location;
      if [[ "${search_location// /}" == "" ]]; then
        warning "Search location is required.";
        search_location="";
        continue;
      fi;
      if [[ ! -d "${search_location}" || ! -r "${search_location}" ]]; then
        warning "Directory [ ${search_location} ] does not exist or is not readable.";
        search_location="";
        continue;
      fi;
    done;

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        newline;
        message "Search Pattern: [ ${search_pattern} ]";
        local count=${#search_terms[@]};
        if (( count == 0 )); then
                warning "No search terms provided or extracted.";
          else  message "Search Terms (${count}): ";
                newline;
                for ((i = 0; i < count && i < 25; i++)); do
                  message "- ${search_terms[$i]}";
                done | cat -n;
        fi;
        newline;
      } >> "${trace_logfile:-/dev/null}";
    fi;
    
    #### -----------------------------------------------------------------------
    ## Resolve config files into configs_listing[]
    declare -a configs_listing=();
    if [[ -n "${search_configs}" ]]; then

          declare -a raw_paths=();
          if [[ -f "${search_configs}" && "${search_configs}" != *,* ]]; then
                    ## Case 1: File input → read device names or config keywords
                    while IFS= read -r line || [[ -n "${line}" ]]; do
                      clean="$(
                        echo "${line}" | \
                        sed 's/\r//' | \
                        sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
                      )";
                      [[ -z "${clean}" || "${clean}" =~ ^#.*$ ]] && continue;
                      raw_paths+=( "${clean}" );
                    done < "${search_configs}";
              else  ## Case 2: Inline input → tokenize using common delimiters
                    IFS=$'\n' read -r -d '' -a raw_paths <<< "$(
                      echo "${search_configs}" | \
                      tr -s '[:space:]+|;:,.' '\n' | \
                      grep -v '^\s*$'
                    )" || true;
            fi;

            if [[ ${#raw_paths[@]} -gt 0 ]]; then
                    mapfile -t configs_listing < <(
                      find "${search_location}" -type f 2>/dev/null | \
                      egrep "$(IFS='|'; echo "${raw_paths[*]}")" | \
                      sed 's|^\./||' | \
                      sort -u
                    );
              else  configs_listing=();
            fi;

            ## Persist resolved configs to disk in one shot for downstream reuse
            search_configs="${TMP_DIR}/configs.list";
            printf "%s\n" "${configs_listing[@]}" > "${search_configs}";

      elif  [[ -n "${search_location}" ]]; then
            if [[ ! -d "${search_location}" ]]; then
              warning "Search location path does not exist: [ ${search_location} ]"
              newline
              return 5;
            fi;
            mapfile -t configs_listing < <(
              find "${search_location}" -type f 2>/dev/null
            );
    fi;

    #### -----------------------------------------------------------------------
    ## Cross-filtering IPs and Configs based on actual matches

    declare -a matched_ips=();
    declare -a matched_configs=();

    local matched=;
    for cfg in "${configs_listing[@]}"; do
      [[ ! -f "${cfg}" ]] && continue;
      matched=false;
      for ip in "${search_terms[@]}"; do
        if grep -qF "${ip}" "${cfg}"; then
          matched_configs+=( "${cfg}" );
          matched_ips+=( "${ip}" );
          matched=true;
        fi;
      done;
    done;

    #### -----------------------------------------------------------------------
    ## Deduplicate and sanitize search-patterns (e.g.: ips) and configs list
    readarray -t matched_ips < <(
      printf "%s\n" "${matched_ips[@]}" | \
      grep -v '^\s*$' | \
      sort -u
    );
    readarray -t configs_listing < <(
      printf "%s\n" "${matched_configs[@]}" | \
      grep -v '^\s*$' | \
      sort -u
    );

    #### -----------------------------------------------------------------------
    ## Abort early if no valid IPs or configs matched
    if [[ ${#matched_ips[@]} -eq 0 || ${#configs_listing[@]} -eq 0 ]]; then
      {
        warning "No matching IPs or valid configuration files were found.";
        if (( ${#search_terms[@]} == 0 )); then
                warning "Search pattern yielded no IPs to evaluate.";
          # else  message "Total IPs provided: ${#search_terms[@]}";
          #       for ip in "${search_terms[@]}"; do
          #         message "- ${ip}";
          #       done | cat -n;
        fi;
        if (( ${#configs_listing[@]} == 0 )); then
                warning "No config files were retained after filtering.";
          # else  message "Config files provided (but no IP match found): ${#configs_listing[@]}";
          #       for cfg in "${configs_listing[@]}"; do
          #         message "- ${cfg}";
          #       done | cat -n;
        fi;
        newline;
        message "Aborting parsing — no valid correlation between IPs and configurations.";
      } >> "${trace_logfile:-/dev/null}";
      return 6;
    fi;

    #### -----------------------------------------------------------------------
    ## Write final validated config file list
    if [[ -w "${search_configs}" ]]; then
            printf "%s\n" "${configs_listing[@]}" > "${search_configs}";
      else  search_configs="${TMP_DIR}/configs.list";
            printf "%s\n" "${configs_listing[@]}" > "${search_configs}";
    fi;

    #### -----------------------------------------------------------------------
    ## Conditionally write .cache/ips.list only if there are matching IPs
    if (( ${#matched_ips[@]} > 0 )); then
            if ! printf "%s\n" "${matched_ips[@]}" > "${active_ips_file}"; then
                    {
                      warning "Failed to write validated IPs to: ${active_ips_file}";
                    } >> "${trace_logfile:-/dev/null}";
                    return 7;
              else  search_pattern="${active_ips_file}";
            fi;
      else  ## Do not create the file — absence is an implicit signal of failure
            {
              warning "No valid IPs were found — skipping creation of: ${active_ips_file}";
              message "Please, check your search pattern or input files.";
              return 8;
            } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    ## Persist filtered configs to .cache/configs.list — always runtime, never fallback
    if (( ${#configs_listing[@]} > 0 )); then
            if ! printf "%s\n" "${configs_listing[@]}" > "${active_configs_file}"; then
              warning "Failed to write validated configs to: ${active_configs_file}";
              return 9;
              else  search_configs="${active_configs_file}";
            fi;
      else  ## Do not create the file — absence is an implicit signal of failure
            {
              warning "No valid Configs were found — skipping creation of: ${active_configs_file}";
              message "Please, check your configurations or input files.";
              return 10;
            } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        message "Validated IPs exported to:  [ ${active_ips_file} ]";
        message "Validated Configs saved to: [ ${active_configs_file} ]";
        # message "IPs retained: ${#matched_ips[@]}";
        # message "Configs retained: ${#configs_listing[@]}";
        newline;
      } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        message "Resolved Configs: [ ${#configs_listing[@]} ]";
        message "Listing Configs:  [ ${search_configs:-${search_location}} ]";
        newline;
        for item in "${configs_listing[@]}"; do
          message "- ${item}";
        done | cat -n;
      } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    # Loop through configs_listing array
    for target_config in "${configs_listing[@]}"; do
      [[ ! -f "${target_config}" ]] && continue;

      #### -----------------------------------------------------------------------
      set +e;
      detect_vendor "${target_config}";
      local vendor_code=${?};
      set -e;
      case "${vendor_code}" in
        1)  target_platform="fortinet";
            ;;
        2)  target_platform="cisco";
            ;;
        3)  target_platform="unknown";
            {
              warning "Unsupported configuration type: ${target_config}";
              newline 2;
            } >> "${trace_logfile:-/dev/null}";
            return 11;
            ;;
        *)  target_platform="unknown";
            {
              warning "Unknown configuration type: ${target_config}";
              newline 2;
            } >> "${trace_logfile:-/dev/null}";
            return 12;
            ;;
      esac;

      #### -----------------------------------------------------------------------
      if [[ "${verbose}" == true ]]; then
        {
          newline;
          message "Source Config: [ ${target_config} ] ( ${target_platform} )";
        } >> "${trace_logfile:-/dev/null}";
      fi;

      #### -----------------------------------------------------------------------
      local base_output="${extract_location%/}"

      if [[ -n "${search_location:-}" && "${search_location}" != false ]]; then
              rel_path="${target_config#${search_location%/}/}";
        else  rel_path="$( basename "${target_config}" )";
      fi;

      local target_output="${base_output}/${rel_path}";
      local output_dir="$( dirname "${target_output}" )";

      mkdir -p "${output_dir}" || {
        warning "Failed to create directory: ${output_dir}" >&2
        newline
        exit 0;
      }
      : > "${target_output}";

      #### -----------------------------------------------------------------------
      declare -a execute=(
        ./scripts/extract-configs.shell
        --search="${active_ips_file}"
        --config="${target_config}"
        --extract="${target_output}"
        --platform="${target_platform}"
      );
      [[ "${verbose}" == true ]] && execute+=( --verbose );

      #### -----------------------------------------------------------------------
      ## Execute and propagate exit status
      if [[ "${verbose}" == true ]]; then
        {
          message "Output Config: [ ${target_output} ]";
          newline;
          for item in "${execute[@]}"; do
            message "\t${item}";
          done;
        } >> "${trace_logfile:-/dev/null}";
      fi;

      $( which bash ) -x "${execute[@]}" >/dev/null 2>&1;

    done;

    tree "${extract_location}";
    newline;

    return 0;
}; alias network-configs='main';

#### -----------------------------------------------------------------------

[[ -z "${script_name+x}" ]] && export script_name="${0}";

export logs_location="logs";
mkdir -p ${logs_location}/console 2>/dev/null || true;

script_filename="${BASH_SOURCE[0]##*/}";
script_filename="${script_filename%.*}";

trace_logfile="${logs_location}/console/${script_filename}.console";
: > "${trace_logfile}";

extract_configs_logfile="${logs_location}/console/extract-configs.console";
touch "${extract_configs_logfile}";

#------------------------------------------------------------------------------#

if [[ ${#@} -eq 0 || "${1,,}" =~ ^-*(h|help)$ ]]; then
        main --help ;
  else  newline;
        main "${@}";
        result=${?}; exit ${result};
        ## newline; message "Done."; newline;
fi;

## -------------------------------------------------------------------------- ##
## Examples: Please, check built-in help (--help) for details
## -------------------------------------------------------------------------- ##
