#!/usr/bin/env bash

## -------------------------------------------------------------------------- ##
## File: scripts/network-configs.shell
##
## Purpose:
##   Top-level dispatcher for pre-processing multi-vendor network configurations.
##   Extracts relevant sections (e.g., ACLs, objects, addresses) based on a
##   user-defined search pattern (typically IP addresses), reducing massive
##   configuration files into targeted, minimal artifacts for faster analysis.
##
## Description:
##   - Acts as a platform-agnostic orchestrator.
##   - Accepts one or more source configs or an entire directory scan.
##   - Automatically detects vendor platform (Cisco, Fortinet).
##   - Delegates execution to `extract-configs.shell` via vendor-specific logic.
##   - Output is a per-config reduced dataset with relevant blocks only.
##   - Results are suitable for use in downstream search/classification pipelines.
##
## Extraction Logic:
##   - Fortinet: matches ‘fortinet’, ‘fortigate’
##   - Cisco: matches ‘asa’, ‘interface’, ‘object’, ‘cisco ios’
##
## Usage:
##   bash ./scripts/network-configs.shell \
##     --ip-addr=198.51.100.75 \
##     --config=./configs/device.cfg \
##     --output=./results/device-reduced.cfg \
##     --verbose
##
## Exit Codes:
##   1 = Missing or empty search pattern
##   2 = Config file not found
##   3 = Unsupported configuration format
##   4 = Unrecognized configuration content
##   5 = Output path creation failed
##
## -------------------------------------------------------------------------- ##

set -euo pipefail  ## Strict mode: exit on error, undefined var use, and pipeline failure
# set -x;          ## Enable for execution tracing/debugging

## POSIX locale standard
export LC_ALL=C   ## Ensure consistent sorting and character handling (POSIX-compliant)

# Create a secure, temporary working directory (auto-cleaned at script exit)
export TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

export nl="\n";

#------------------------------------------------------------------------------#
function display_help () {
    local -a help_lines=();
    local indent="    ";
    local padding="$( printf '%*s' ${#script_name} ' ' )";
    ## Header
    help_lines+=( "Usage: ${script_name} [OPTIONS]${nl}" );
    ## Shared Options
    help_lines+=( "Options:${nl}" );
    help_lines+=( "  -i, --ip-addr      Custom Search Pattern: IP Address, etc." );
    help_lines+=( "  -c, --config       Single (target) Configuration filepath to be parsed" );
    help_lines+=( "  -s, --search       Configurations listing to be located (files: {abc,def,ghi}.cfg)" );
    help_lines+=( "  -l, --location     Requires to listing all files matching a criteria (files: *.cfg)" );
    help_lines+=( "  -o, --output       Output Filepath for extracted datasets (*.cfg)" );
    ## Flags
    help_lines+=( "Flags:${nl}" );
    help_lines+=( "  --help             Show this help message and exit" );
    # help_lines+=( "  --debug            Enable debug mode with trace output" );
    # help_lines+=( "  --dry-run          Print actions without executing them" );
    help_lines+=( "  --verbose          Enable verbose output${nl}" );
    ## Output
    newline;
    for line in "${help_lines[@]}"; do
      message "${indent}${line}";
    done;
    return 0;
}; alias display-help='display_help'

#------------------------------------------------------------------------------#
## Output Utilities: Print N newlines (default: 1)
function newline () {
    local count="${1:-1}";
    for ((i = 0; i < count; i++)); do echo; done;
    # return 0;
  }; alias new-line='newline';

#------------------------------------------------------------------------------#
## Output Utilities: Print an error message in consistent format
function message () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -e "${message}";
    # return 0;
  }; alias print-message='message';

#------------------------------------------------------------------------------#
function detect_vendor () {
    local config_file="${1}";
    local fortinet_pattern='fortinet|fortigate';
    local cisco_pattern='\basa\b|cisco ios|cisco adaptive|^interface\b|^object\b';
    if grep -qiE "${fortinet_pattern}" "${config_file}"; then
            return 1;
      elif  grep -qiE "${cisco_pattern}" "${config_file}" 2>/dev/null; then
            return 2;
      else  return 3;
    fi;
    return 0;
}; alias detect-vendor='detect_vendor';

#------------------------------------------------------------------------------#
function main () {
    ## tracking_process ${FUNCNAME} "${@}";
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(ip-addr|i)$ ]] && export search_pattern="${value}";
      [[ $key =~ ^(config|c)$ ]] && export source_config="${value}";
      [[ $key =~ ^(output|o)$ ]] && export output_config="${value}";

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && local debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true;
    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied
    [[ -z ${script_helper:-} ]] && script_helper=false;
    [[ -z ${debug:-} ]] && debug=false;
    [[ -z ${dry_run:-} ]] && dry_run=false;
    [[ -z ${verbose:-} ]] && verbose=false;

    #### -----------------------------------------------------------------------
    ## Display usage help if requested
    if [[ ${script_helper:-} == true ]]; then
      display_help;
      exit 0;
    fi;

    declare -a configs_listing=();

    #### -----------------------------------------------------------------------
    while [[ -z ${search_pattern:-} ]]; do
      newline;
      read -e -p "Enter target search pattern: " search_pattern
      if [[ "${search_pattern:-}" =~ ^[[:space:]]*$ ]]; then
        message "Warning: Pattern cannot be empty!" >&2;
        newline;
        exit 1;
      fi;
    done;

    #### -----------------------------------------------------------------------
    while [[ -z ${source_config:-} || ! -f "${source_config}" ]]; do
      newline;
      read -e -p "Enter source configuration file: " source_config
      # message "Source Config: ${source_config}";
      if [[ ! -f "${source_config}" ]]; then
        message "Warning: File does not exist!" >&2;
        newline;
        exit 2;
      fi;
    done;

    # Copy into array for uniform downstream processing
    configs_listing=( "${source_config}" );

    #### -----------------------------------------------------------------------
    # Loop through configs_listing array
    for source_config in "${configs_listing[@]}"; do
      [[ ! -f "${source_config}" ]] && continue;

      #### -----------------------------------------------------------------------
      set +e;
      detect_vendor "${source_config}";
      local vendor_code=${?};
      # message "Vendor Code: ${vendor_code}";
      set -e;
      case "${vendor_code}" in
        1)  target_platform="fortinet";
            ;;
        2)  target_platform="cisco";
            ;;
        3)  message "Unsupported configuration type: ${source_config}";
            newline 2;
            exit 3;
            ;;
        *)  message "Unknown configuration type: ${source_config}";
            newline 2;
            exit 4;
            ;;
      esac;

      #### -----------------------------------------------------------------------
      if [[ -n ${output_config:-} ]]; then
              local output_dir="$( dirname "${output_config}" )";
              if [[ ! -d "${output_dir}" ]]; then
                mkdir -p "${output_dir}" || {
                  message "Warning: Failed to create output directory: ${output_dir}" >&2;
                  newline;
                  exit 5;
                };
              fi;
        else  local output_config="$( pwd )/${target_platform}--$(
                      basename ${source_config/.cfg/}
                    ).cfg";
      fi;

      #### -----------------------------------------------------------------------
      declare -a execute=(
        ./scripts/extract-configs.shell
        --ip-addr="${search_pattern}"
        --config="${source_config}"
        --output="${output_config}"
      );
      [[ "${verbose}" == true ]] && execute+=( --verbose );

      #### -----------------------------------------------------------------------
      ## Execute and propagate exit status
      $( which bash ) "${execute[@]}" >/dev/null 2>&1;

      if [[ "${verbose}" == true ]]; then
        newline;
        cat -n "${output_config}";
        newline 2;
      fi;

      ls -al "${output_config}";
      newline;

    done;

    return 0;
}; alias parse-cisco='main';

[[ -z "${script_name+x}" ]] && export script_name="${0}";

#------------------------------------------------------------------------------#

if [[ ${#@} -ge 1 && "${1,,}" =~ ^-*(h|help)$ ]]; then
        main --help ;
  else  main "${@}";
        result=${?}; exit ${result};
        ## newline; message "Done."; newline;
fi;

## -------------------------------------------------------------------------- ##
## Examples:
##
## 1. Cisco — Extract entries referencing a known IP:
##    bash scripts/network-configs.shell \
##         --ip-addr="198.51.100.75" \
##         --config=configs/cisco/branch-isr-02.cfg \
##         --output=tmp/branch-isr-02-reduced.cfg \
##         --verbose
##
## 2. Fortinet — Extract from lab firewall using shared IP:
##    bash scripts/network-configs.shell \
##         --ip-addr="198.51.100.75" \
##         --config=configs/fortinet/fg-lab-test-fw.cfg \
##         --output=tmp/fg-lab-test-fw-reduced.cfg \
##         --verbose
##
## 3. Cisco — Match multiple IP addresses in a single pass:
##    bash scripts/network-configs.shell \
##         --ip-addr="10.0.2.3,172.16.1.6" \
##         --config=configs/cisco/branch-isr-02.cfg \
##         --output=tmp/branch-isr-02-multi.cfg \
##         --verbose
##
## 4. Fortinet — Match subnet blocks (set subnet commands):
##    bash scripts/network-configs.shell \
##         --ip-addr="192.168.1.10,203.0.113.25" \
##         --config=configs/fortinet/fg-lab-test-fw.cfg \
##         --output=tmp/fg-lab-test-fw-subnets.cfg \
##         --verbose
##
## 5. Auto-detect output path (no --output specified):
##    bash scripts/network-configs.shell \
##         --ip-addr="10.0.0.1" \
##         --config=configs/fortinet/fg-lab-test-fw.cfg \
##         --verbose
##
## Notes:
##   - Search patterns can include IPs, phrases, or edit keys.
##   - The --output flag is optional; auto-names will be generated if omitted.
##   - Additional support for --location and --configs coming soon.
## -------------------------------------------------------------------------- ##
