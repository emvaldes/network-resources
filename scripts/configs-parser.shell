#!/usr/bin/env bash

## File: scripts/configs-parser.shell

## Purpose: Consolidated extraction function per official execution plan.

## Prevent re-sourcing and ensure one-time initialization
if [[ -n "${__CONFIGS_PARSER_SOURCED:-}" ]]; then return 0; fi;
readonly __CONFIGS_PARSER_SOURCED=1;

## -------------------------------------------------------------------------- ##
## Function: configs-parser :: configs_parser ()
##
## Purpose:
##   Main entrypoint for per-IP parsing pipeline. Replaces `parse-configs.shell`.
##   Drives the full parsing lifecycle from argument handling to report generation.
##
## Responsibilities:
##   - Parses CLI arguments and applies defaults for configs, reports, and matrix
##   - Extracts relevant config paths for a given target IP
##   - Validates input files and structures
##   - Applies grouping/classification (if enabled) via matrix matching
##   - Executes `extract_configs()` to collect relevant config blocks
##   - Deduplicates and merges structured JSON objects per IP
##   - Stores final output under `${reports_location}/<ip>/<ip>.json`
##
## Input Parameters (as key=value args):
##   - ip-addr      : IP address to process (required)
##   - configs      : Path to configuration root folder (default: ./configs)
##   - reports      : Path to write output JSON (default: ./reports)
##   - matrix       : Translation matrix for classification (optional)
##   - file-ext     : Comma-delimited list of config extensions (default: cfg,conf,cnf)
##   - index        : Optional ID used for per-IP processing context
##   - validate     : Enables IP format validation before proceeding
##   - classify     : Enables matrix-based group classification
##   - verbose/debug/dry-run/help/logs : Optional behavior toggles
##
## Output:
##   - Structured per-IP JSON report at ${reports_location}/<ip>/<ip>.json
##   - Temp fragments, logs, and debug traces under ${TMP_DIR}
##
## Notes:
##   - Replaces standalone script `parse-configs.shell` with fully modular logic
##   - Compatible with batch systems that expect this function to be run in parallel
## -------------------------------------------------------------------------- ##

function configs_parser () {

    ## tracking_process ${FUNCNAME} "${@}";
    declare -a file_extensions=();
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do

      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(classify|g)$ ]] && export classify_targets=true;
      [[ $key =~ ^(configs|c)$ ]] && export configs_dirpath="${value}";
      [[ $key =~ ^(file-ext|x)$ ]] && file_extensions+=(
        $( print "${value}" | tr ':,;\n ' '\n' )
      );
      [[ $key =~ ^(index|n)$ ]] && local target_index="${value}";
      [[ $key =~ ^(ip-addr|i)$ ]] && local target_address="${value}";
      [[ $key =~ ^(logs|o)$ ]] && export enable_logging=true;
      [[ $key =~ ^(matrix|m)$ ]] && local matrix_filename="${value}";
      [[ $key =~ ^(reports|r)$ ]] && local reports_location="${value}";
      [[ $key =~ ^(validate|v)$ ]] && local validate_address=true;

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && export debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && export verbose=true;

    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied
    [[ -z ${debug:-} ]] && export debug=false;
    [[ -z ${verbose:-} ]] && export verbose=false;

    #### -----------------------------------------------------------------------
    ## Display usage help if requested
    if [[ ${script_helper:-} == true ]]; then
      display_help "${script_name}" "configs";
      exit 0;
    fi;

    export parse_configs__logfile="${logs_location}/configs-parser.log";
    :> "${parse_configs__logfile}";

    local extract_configs__logfile="${TMP_DIR}/parse-configs--extract-configs.log";
    :> "${extract_configs__logfile}";

    #### -----------------------------------------------------------------------
    [[ -z ${matrix_filename:-} ]] && export classify_targets="matrix.json";
    if [[ ! -f "${matrix_filename}" ]]; then
      warning "Translation Matrix file '${matrix_filename}' was not found!";
    fi;

    #### -----------------------------------------------------------------------
    ## Enabling IP/CIDR Blocks Group Classification
    [[ -z ${classify_targets:-} ]] && export classify_targets=false;

    #### -----------------------------------------------------------------------
    ## Target Configurations (file-extensions):
    ## Set default file extensions if none provided
    if [[ -z ${file_extensions+x} || ${#file_extensions[@]} -eq 0 ]]; then
      declare -a file_extensions=( cfg conf cnf );
    fi;

    #### -----------------------------------------------------------------------
    ## Load all source configs from target JSON
    export configs_dirpath="${configs_dirpath:-configs}";
    declare -ga source_configs=();

    local target_configlist_json="targets/${target_address}.json";
    if [[ ! -f "${target_configlist_json}" ]]; then
      [[ "${verbose}" == true ]] && \
        warning "Required config list not found: ${target_configlist_json}";
      return 3;
    fi;

    message "Loading target config list from: ${target_configlist_json}";

    # mapfile -t source_configs < <(
    #   jq -r '
    #     .locations | to_entries[] |
    #     .key as $site |
    #     .value.devices[] |
    #     "\($site)/\(.config.file)"
    #   ' "${target_configlist_json}"
    # )
    mapfile -t source_configs < <(
      jq -r '
        .locations | to_entries[] |
        .key as $site |
        .value.devices[] |
        "\($site)/.objects/\(.config.file | split(".")[0]).list"
      ' "${target_configlist_json}"
    )

    [[ "${verbose}" == true ]] && {
      message "Found ${#source_configs[@]} config files:";
      for item in "${source_configs[@]}"; do
        message "  - ${item}";
      done;
    }

    #### -----------------------------------------------------------------------
    ## Normalize paths (prepend configs_dirpath if relative)
    for i in "${!source_configs[@]}"; do
      if [[ "${source_configs[$i]}" != "${reports_location}/${target_address}/"* ]]; then
        source_configs[$i]="${source_configs[$i]}"
      fi;

      #### -----------------------------------------------------------------------
      ## Processing Custom/Default the Translation-Matrix (source):
      ## Load and validate translation matrix (used for grouping logic)

      if [[ "${classify_targets}" == true ]]; then
        if [[ ! -f "${matrix_filename}" ]]; then
                [[ "${verbose}" == true ]] && \
                  warning "Project Source Matrix-Configs file not found: ${matrix_filename}";
                return 7;
          elif  ! jq -e 'length > 0' "${matrix_filename}" &>/dev/null; then
                [[ "${verbose}" == true ]] && \
                  warning "Matrix file is missing, invalid, or empty: ${matrix_filename}";
                return 8;
          else  export matrix_configs="$( cat "${matrix_filename}" )";
        fi;
      fi;

      #### -----------------------------------------------------------------------
      ## Custom/Default reports folder:
      export reports_location="${reports_location:-reports}";
      
      #### -----------------------------------------------------------------------
      ## Presetting Target-Index Marker
      [[ -z ${target_index:-} ]] && target_index='';

      #### -----------------------------------------------------------------------
      ## Validating IP Addresses (Skipping?)
      [[ -z ${validate_address:-} ]] && export validate_address=false;

      ## Target IP Address (required):
      if [[ -z "${target_address:-}" ]]; then
              [[ "${debug}" == true ]] && \
                warning "No IP address provided.";
              return 2;
        else  target_address="$(
                print "${target_address}" | sed -E 's/[[:space:]]+//g' | tr -d '\r'
              )";
              ## Validating Target-Address (IP/CIDR):
              if [[ ${validate_address} == true ]]; then
                validate_address;
              fi;
      fi;

      #### -----------------------------------------------------------------------
      # export tmp_json="${TMP_DIR}/partial.json";
      export tmp_fragments="${TMP_DIR}/fragments.json";

      #### -----------------------------------------------------------------------
      for cfg_file in "${source_configs[@]}"; do
        extract_configs "${cfg_file}" \
                        "${target_address}" \
                        "${target_configlist_json}" \
                        "${tmp_fragments}" \
                        "${extract_configs__logfile}" \
        ;
      done;

      ## Insert diagnostic check here
      if [[ "${verbose}" == true && -s "${tmp_fragments}" ]]; then
        {
          jq -r '.[] | "\(.site)/\(.device) → \( .objects | length ) objects"' "${tmp_fragments}"
          newline
        } >> "${parse_configs__logfile:-/dev/null}";
      fi;

    done;

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        print_file "${extract_configs__logfile:-/dev/null}";
      } >> "${parse_configs__logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    ## Ensure batch output subdirectory exists
    mkdir -p "${TMP_DIR}/${target_address}";

    ## Create a temporary batch-specific output file for this IP
    export json_outfile="${TMP_DIR}/${target_address}/${target_address}.json";

    if [[ "${verbose}" == true ]]; then
      if [[ -s "${tmp_fragments}" ]]; then
        {
          jq  --raw-output \
              --slurp \
              --arg ipref "targets/${target_address}.json" \
                          '
                          sort_by( .site, .device ) |
                          group_by( .site + "/" + .device )[] as $group |
                          "- " + ( $group[0].site + "/" + $group[0].device ) + 
                          " ( " + ( $group | length | tostring ) + " fragments ) -> " + $ipref,
                          (
                            $group[].objects[]? |
                            "  • object: " + ( .object // "unknown" ) + 
                            " ( type: " + ( .type // "n/a" ) + " )"
                          )
                          ' "${tmp_fragments}";
          newline;
        } >> "${parse_configs__logfile:-/dev/null}";
      fi;
    fi;

    if [[ -s "${tmp_fragments}" ]]; then

      jq --slurp --arg target "${target_address}" \
                              '{ target: $target, configs: . }' \
                              "${tmp_fragments}" \
      > "${json_outfile}";
      if [[ "${verbose}" == true ]]; then
        {
          print_file "${json_outfile}";
          newline;
        } >> "${parse_configs__logfile:-/dev/null}";
      fi;

      #### ---------------------------------------------------------------------
      ## Merge batch result into persistent output for this IP
      tmp_merged="$( mktemp )";
      local final_outfile="${reports_location}/${target_address}/${target_address}.json";
      mkdir -p "$(
        dirname "${final_outfile}"
      )";

      #### ---------------------------------------------------------------------
      # Objective: Merge logic for per-IP JSON output.
      # Ensures that if a config (by site/device) already exists, its `.objects` array
      # is merged with the incoming batch and deduplicated based on composite fields
      # (.type, .name, .object, .sets). This prevents bloating caused by re-appending
      # identical blocks across batches or multiple runs.

      local jq_merge_expr=$'{
        target: .[0].target,
        configs:
          ( reduce .[].configs[] as $cfg (
            [];
            if any( .[]; .site == $cfg.site and .device == $cfg.device )
              then map(
                if .site == $cfg.site and .device == $cfg.device
                  then .objects = (
                    ( .objects + $cfg.objects )
                    | unique_by( .type, .name, .object, ( .sets | tostring ) )
                  )
                else . end
              )
            else . + [ $cfg ] end
          ))
      }';

      if [[ -f "${final_outfile}" ]]; then
              jq --slurp "${jq_merge_expr}" \
                         "${final_outfile}" \
                         "${json_outfile}" \
              > "${tmp_merged}";
        else  jq --slurp "${jq_merge_expr}" \
                         "${json_outfile}" \
              > "${tmp_merged}";
      fi;
      mv "${tmp_merged}" "${final_outfile}" && \
      rm -f "${json_outfile}";

      if [[ "${verbose}" == true ]]; then
        {
          print "Merged [ targets/${target_address}.json ] → ${final_outfile}";
          newline 2;
        } >> "${parse_configs__logfile:-/dev/null}";
      fi;

    fi;

    if [[ "${verbose}" == true ]]; then
      {
        print_file "${parse_configs__logfile:-/dev/null}";
      } >> "${actions_logfile:-/dev/null}";
    fi;

    return 0;
}; alias configs-parser='configs_parser';

## -------------------------------------------------------------------------- ##
## Function: configs-parser :: extract_configs ()
##
## Purpose:
##   Parses a given configuration file, extracts all objects containing a target IP,
##   and writes structured per-object metadata into a JSON fragments file.
##
## Inputs:
##   $1 = Full path to the configuration file
##   $2 = Target IP address (used as search pattern)
##   $3 = JSON fragments output file (collector for wrapped objects)
##   $4 = Unused (was originally a named array output; logic now internalized)
##
## Workflow:
##   - Reads and sanitizes the full config file (removes blank lines, comments, etc.)
##   - Splits config into logical blocks (using `${divisor}` as the delimiter)
##   - Restores the blocks into newline-separated format
##   - Filters blocks containing the target IP
##   - Writes matched config blocks to `${reports_location}/<ip>/<site>/<device>.<ext>`
##   - Processes each matched block with `process_configs` to extract metadata
##   - Wraps extracted objects under `{ site, device, objects[] }` structure
##   - Appends each structured result to the final JSON fragment output file
##
## Output:
##   - Structured per-config JSON entries written to $3
##   - Raw matched blocks written to `${reports_location}/<ip>/<site>/<device>.<ext>`
##
## Notes:
##   - Duplicate blocks are skipped via flat-string comparison.
##   - Preserves traceability and grouping by site/device.
##   - Designed to run synchronously per config file, called from `parse-configs`.
## -------------------------------------------------------------------------- ##

function legacy__extract_configs () {

    local config_file="${1}";
    local target_pattern="${2}";
    local target_listing="${3}";
    local json_output="${4}";

    ## Recording the generated_configslist actions
    local target_logfile="${5:-${TMP_DIR:-/tmp}/tools-configs--extract-configs--${ip_addr}.log}";

    # local target_object="${TMP_DIR}/$(basename "${config_file}").objects"

    # #### -----------------------------------------------------------------------
    # ## Validate file exists
    # if [[ ! -f "${config_file}" ]]; then
    #   warning "[extract_configs] Config file not found: ${config_file}";
    #   return 1;
    # fi;

    # #### -----------------------------------------------------------------------
    # ## Check if config file exists or is empty
    # if [[ "${verbose}" == true ]]; then
    #   {
    #     # message "[extract_configs] Processing file:  ${config_file:-/dev/null}";
    #     # message "[extract_configs] Target Listing:   ${target_listing:-/dev/null}";
    #     if [[ ! -s "${config_file}" ]]; then
    #       message "Warning: Configuration file '${config_file}' is missing or empty!";
    #     fi;
    #     # newline;
    #   } >> "${target_logfile:-/dev/null}";
    # fi;

    # #### -----------------------------------------------------------------------
    # ## Read and sanitize config file into array
    # mapfile -t config_rawdata < <(
    #   sed '/^\s*$/d;/^\s*!.*$/d' < "${config_file}"
    # );

    # #### -----------------------------------------------------------------------
    # ## Extract first 6 lines as metadata
    # local metadata_header="$(
    #   printf '%s\n' "${config_rawdata[@]:0:7}"
    # )";

    # #### -----------------------------------------------------------------------
    # ## Remove metadata from config
    # sanitized_content=( "${config_rawdata[@]:7}" );

    # #### -----------------------------------------------------------------------
    # if [[ "${verbose}" == true ]]; then
    #   {
    #     message "[extract_configs] Metadata Header:";
    #     message "${metadata_header}";
    #     newline;
    #     message "Sanitized Content [${config_file}]:";
    #     for line in "${sanitized_content[@]}"; do
    #       message "${line}";
    #     done;
    #     newline;
    #   } >> "${target_logfile:-/dev/null}";
    # fi;

    # #### -----------------------------------------------------------------------
    # ## Derive location/device/ext from config path
    # local cfg_path="${config_file}";
    # message "[extract_configs] Config Path: ${cfg_path}";
    # local rel_path="${cfg_path#${configs_dirpath}/}";  ## e.g., cisco/fw1.cfg
    # message "[extract_configs] Relative Path: ${rel_path}";
    # local site="${rel_path%%/*}";                      ## -> cisco
    # message "[extract_configs] Site: ${site}";
    # local device_filename="${rel_path#*/}";            ## -> fw1.cfg
    # message "[extract_configs] Device Filename: ${device_filename}";
    # local extension="${device_filename##*.}";          ## -> cfg
    # message "[extract_configs] Extension: ${extension}";

    # ## Construct output path: ${reports_location}/<ip-address>/<location>/<device>.<ext>
    # local objects_dir="${reports_location}/${target_address}/${site}";
    # local objects_file="${objects_dir}/${device_filename}";

    # #### -----------------------------------------------------------------------
    # mkdir -p "${objects_dir}" 2>/dev/null || true;

    # $( which bash ) -x ./scripts/network-configs.shell \
    #                 --ips-list="${target_pattern}" \
    #                 --config="${config_file}" \
    #                 --output="${objects_file}" \
    # ;

    # #### -----------------------------------------------------------------------
    # if [[ "${verbose}" == true ]]; then
    #   {
    #     message "[extract_configs] Extracted config into: ${objects_file}";
    #     ls -al "${objects_file}" || true;
    #   } >> "${target_logfile:-/dev/null}";
    # fi;

    # # #### -----------------------------------------------------------------------
    # # ## Load extracted config from disk into matched_objects
    # # mapfile -t __matched_objects__ < "${objects_file}";

    # # if [[ "${#__matched_objects__[@]}" -eq 0 ]]; then
    # #   if [[ "${verbose}" == true ]]; then
    # #     {
    # #       message "[extract_configs] No configuration lines loaded from: ${objects_file}";
    # #     } >> "${target_logfile:-/dev/null}";
    # #   fi;
    # # fi;

    # # if [[ "${verbose}" == true ]]; then
    # #   {
    # #     message "[extract_configs] Loaded ${#__matched_objects__[@]} lines from: ${objects_file}";
    # #     for i in "${!__matched_objects__[@]}"; do
    # #       message "|---> Line [${i}]: ${__matched_objects__[$i]}";
    # #     done; newline;
    # #   } >> "${target_logfile:-/dev/null}";
    # # fi;

    # #### -----------------------------------------------------------------------
    # ## [INSERT HERE] Check if config is readable and has content
    # message "[DEBUG] Checking if config file exists and is readable: ${config_file}";
    # if [[ ! -s "${config_file}" ]]; then
    #         warning "File '${config_file}' is missing or empty";
    #   else  message "[OK] File '${config_file}' is readable and size is $(
    #           stat -f "%m" "${config_file}"
    #         ) bytes";
    # fi;

    #### -----------------------------------------------------------------------
    ## Full file ingestion and normalization
    local imported_content="$( < "${reports_location}/${target_pattern}/${config_file}" )";
    if [[ "${verbose}" == true ]]; then
      message "Imported Content: ${imported_content[@]}";
    fi;

    #### -----------------------------------------------------------------------
    ## Remove multiple and/or empty blank lines plus "!"
    local sanitized_content="$(
      sed '/^\s*$/d;/^\s*!.*$/d' <<< "${imported_content}"
    )";
    if [[ "${verbose}" == true ]]; then
      message "Sanitized Content: ${sanitized_content[@]}";
    fi;

    #### -----------------------------------------------------------------------
    ## Replace newlines with date-base64 string (divisor)
    local serialized_objects="$(
      perl -pe 's/\n/'"${divisor}"'/g' <<< "${sanitized_content}"
    )";
    if [[ "${verbose}" == true ]]; then
      message "Serialized Objects: ${serialized_objects[@]}";
    fi;

    #### -----------------------------------------------------------------------
    ## Restoring configuration objects: inject real newlines after each object
    local restored_lines="$(
      sed -E "s/${divisor}([^[:space:]])/\n\1/g" <<< "${serialized_objects}"
    )";
    # Ensure each line ends with a literal newline (required for proper splitting)
    restored_lines+=$'\n';
    # Convert to array by splitting on real newlines between objects
    IFS=$'\n' read -r -d '' -a config_objects < <(
      printf '%s\0' "${restored_lines}"
    );

    if [[ "${verbose}" == true ]]; then
      message "Loaded ${#config_objects[@]} config blocks";
      # for i in "${!config_objects[@]}"; do
      #   message "|---> Block [${i}]\n${config_objects[$i]}";
      # done; newline;
    fi;

    #### -----------------------------------------------------------------------
    ## Match config-objects (blocks) containing search-pattern (e.g.: IP Address)
    oIFS="${IFS}"; IFS=$'\n';

    # declare -a matched_objects=($(
    #   printf "%s\n" "${config_objects[@]}" | \
    #   grep -E "(^|[^0-9.])${target_pattern//./\\.}([^0-9.]|$)"
    # ));

    declare -a matched_objects=();
    for block in "${config_objects[@]}"; do
      if grep -qE "(^|[^0-9.])${target_pattern//./\\.}([^0-9.]|$)" <<< "${block}"; then
        matched_objects+=( "${block}" );
      fi;
    done;

    IFS="${oIFS}";

    if [[ "${verbose}" == true ]]; then
      message "Loaded ${#matched_objects[@]} config blocks";
      # for i in "${!matched_objects[@]}"; do
      #   message "|---> Block [$i]\n${matched_objects[$i]}"
      # done; newline;
    fi;

  #### Marked for removal (end-block)

    #### -----------------------------------------------------------------------
    local process_configs__logfile="${TMP_DIR}/tools-configs--process-configs.logs";
    :> "${process_configs__logfile}";

    #### -----------------------------------------------------------------------
    ## Deserializing matched_objects:
    for serialized_line in "${matched_objects[@]}"; do
      [[ "${verbose}" == true ]] && \
         message "Serialized Line: ${serialized_line[@]}";

      restored_block="$(
        perl -pe 's/'"${divisor}"'/\n/g' <<< "${serialized_line}"
      )"
      # restored_block="${restored_block}"$'\n';

      ## Derive site/device/ext from config path
      local cfg_path="${config_file}";
      local rel_path="${cfg_path#${configs_dirpath}/}";  ## e.g., cisco/fw1.cfg
      local site="${rel_path%%/*}";                      ## -> cisco
      local device_filename="${rel_path#*/}";            ## -> fw1.cfg
      local extension="${device_filename##*.}";          ## -> cfg

      ## Construct output path: ${reports_location}/<ip-address>/<location>/<device>.<ext>
      local objects_dir="${reports_location}/${target_address}/${site}";
      local objects_file="${objects_dir}/${device_filename}";

      ## Skip if this block already exists in the output file (match as single line)
      if [[ -s "${objects_file}" ]]; then
        local restored_flat="$( echo "${restored_block}" | tr '\n' '\r' )";
        local objects_flat="$( tr '\n' '\r' < "${objects_file}" )";

        if grep -Fq -- "${restored_flat}" <<< "${objects_flat}"; then
          [[ "${debug}" == true ]] && \
            message "Skipping duplicate block in ${objects_file}";
          continue;
        fi;
      fi;

      mkdir -p "${objects_dir}" 2>/dev/null || true;
      {
        message "${restored_block}";
        message "!";
        newline;
      } >> "${objects_file}";

      if [[ "${verbose}" == true ]]; then
        message "Restored Configuration:\n${restored_block[@]}";
      fi;

      process_configs "${target_pattern}" \
                      "${config_file}" \
                      "${restored_block}" \
                      "${process_configs__logfile}" \
      ;

      if [[ -n "${target_object:-}" ]]; then
        if [[ "${verbose}" == true ]]; then
          message "|-----> Target Objects: ${target_object}";
        fi;
      fi;

      #### -----------------------------------------------------------------------
      if [[ "${verbose}" == true ]]; then
        {
          print_file "${process_configs__logfile:-/dev/null}";
        } >> "${target_logfile:-/dev/null}";
      fi;

      #### -----------------------------------------------------------------------
      ## Append structured config object to fragments file (now final collector)
      if [[ -n "${target_object}" ]]; then
        wrapped_block="$(
          printf '%s\n' "${target_object}" | \
          jq --slurp \
            --arg site "${config_file%/*}" \
            --arg device "${config_file##*/}" \
            '{
              site: ( $site | gsub( "^.*/"; "" ) ),
              device: $device,
              objects: .
            }'
        )";

        # Optionally inspect it
        [[ "${debug}" == true ]] && \
           message "|-----> Config Objects:\n${wrapped_block}";

        # Append to collector file
        print "${wrapped_block}" >> "${json_output}";
        # [[ "${debug}" == true ]] && \
        #    print_file "${json_output}";

      fi;

    done;

    return 0;
}; alias legacy--extract-configs='legacy__extract_configs';

function extract_configs () {

    local relative_list_path="${1}"       # e.g., fortinet/.objects/fw1.list
    local target_pattern="${2}"           # e.g., 10.0.0.1
    local target_configlist_json="${3}"   # e.g., targets/10.0.0.1.json
    local json_output="${4}"              # e.g., TMP_DIR/fragments.json
    local target_logfile="${5:-${TMP_DIR}/tools-configs--extract-configs--${target_pattern}.log}"

    local full_list_path="${reports_location}/${target_pattern}/${relative_list_path}"

    [[ ! -f "${full_list_path}" ]] && {
      warning "Missing serialized file: ${full_list_path}"
      return 1
    }

    local site="${relative_list_path%%/*}"
    local filename="${relative_list_path##*/}"
    local device="${filename%.list}"

    declare -a objects_json=()

    while IFS= read -r serialized_line || [[ -n "${serialized_line}" ]]; do
      [[ -z "${serialized_line}" ]] && continue

      # Deserialize block
      local restored_block
      restored_block="$( sed "s/${divisor}/\n/g" <<< "${serialized_line}" )"

      [[ "${verbose}" == true ]] && message "[restored] →\n${restored_block}"

      process_configs "${target_pattern}" \
                      "${relative_list_path}" \
                      "${restored_block}" \
                      "${target_logfile}"

      [[ -n "${target_object}" ]] && objects_json+=( "${target_object}" )
    done < "${full_list_path}"

    if (( ${#objects_json[@]} > 0 )); then
      printf '%s\n' "${objects_json[@]}" | \
        jq --slurp \
           --arg site "${site}" \
           --arg device "${device}" \
           '{ site: $site, device: $device, objects: . }' \
        >> "${json_output}"
    fi

    return 0
}; alias extract-configs='extract_configs';

## -------------------------------------------------------------------------- ##
## Function: configs-parser :: process_configs ()
##
## Purpose:
##   Analyzes a single configuration block that matched a target IP.
##   Extracts structured metadata and builds a normalized JSON object
##   for inclusion in the per-config object set.
##
## Inputs:
##   $1 = Target IP (used as match pattern)
##   $2 = Full path to the source configuration file (for context only)
##   $3 = Restored configuration block (newline-separated)
##
## Output:
##   - Exports `target_object` as a JSON-formatted Bash variable for upstream collection
##     (usually by `extract_configs()`).
##
## Structure of output JSON:
##   {
##     "object": "<first keyword>",
##     "type": "<object type or false>",
##     "partner": "<non-IP name from 'type'>",
##     "description": "<first matched description or false>",
##     "items": [ "<lines matching target IP>" ],
##     "sets": { "<first-token>": count, ... },
##     "group": "<classification label or 'Unclassified'>"
##   }
##
## Behavior:
##   - Sanitizes and parses the block into components.
##   - Extracts lines relevant to the target IP (`items[]`).
##   - Counts command keywords for `sets{}` mapping.
##   - Parses descriptions, object names, and classifies the entry via matrix.
##   - Avoids duplication or incorrect grouping by delegating output to caller.
##
## Notes:
##   - Skips blocks with no IP match.
##   - If classification is enabled, assigns the best-fit group from matrix.json.
##   - Does not write to file directly — upstream function handles final wrapping.
## -------------------------------------------------------------------------- ##

function process_configs () {

    local target_pattern="$1";
    local config_path="$2";
    local restored_block="$3";

    ## Recording the generated_configslist actions
    local target_logfile="${4:-${TMP_DIR:-/tmp}/tools-configs--process-configs--${ip_addr}.log}";

    #### -----------------------------------------------------------------------
    ## Sanitize and validate non-empty block
    local cleaned_block;
    cleaned_block="$(
      sed '/^[[:space:]]*$/d' <<< "${restored_block}"
    )";
    [[ -z "${cleaned_block}" ]] && return;

    if [[ "${verbose}" == true ]]; then
      message "[process_configs] Raw Block:\n${restored_block}";
    fi;

    #### -----------------------------------------------------------------------
    ## Extract object line (first non-empty line)
    local object_line;
    object_line="$(
      head -n 1 <<< "${cleaned_block}" | \
      sed -E 's/^[[:space:]]*//;s/[[:space:]]*$//'
    )";
    [[ -z "${object_line}" ]] && return;

    #### -----------------------------------------------------------------------
    ## Parse object keyword and type value
    local object_keyword type_value;
    object_keyword="$(
      awk '{print $1}' <<< "${object_line}"
    )";

    # Only extract type if the block is multiline (has more than one non-empty line)
    if (( $( wc -l <<< "${cleaned_block}" ) > 1 )); then
            type_value="$(
              sed -E 's/^[^[:space:]]+[[:space:]]+//' <<< "${object_line}"
            )";
            [[ -z "${type_value}" ]] && type_value="false";
      else  type_value="false";
    fi;

    if [[ "${verbose}" == true ]]; then
      print "[process_configs] object   : ${object_keyword}";
      print "[process_configs] type     : ${type_value}";
    fi;

    #### -----------------------------------------------------------------------
    ## Extract all lines (object memebers) except description
    local -a data_sets=();
    while IFS= read -r line; do
      local trimmed="$(
        sed -E 's/^[[:space:]]*//;s/[[:space:]]*$//' <<< "${line}"
      )";
      [[ -z "${trimmed}" ]] && continue;
      [[ "${trimmed,,}" =~ ^description[[:space:]] ]] && continue;
      data_sets+=( "${trimmed}" );
    done <<< "${cleaned_block}";

    ## Remove object header line if multiple entries
    if (( ${#data_sets[@]} > 1 )); then
      data_sets=( "${data_sets[@]:1}" );
    fi;

    if [[ "${verbose}" == true ]]; then
      message "[process_configs] Object Sets:";
      for e in "${data_sets[@]}"; do
        print "  - ${e}";
      done;
    fi;

    #### -----------------------------------------------------------------------
    ## Extract first line containing target IP
    local matched_line="$(
      grep -E "(^|[^0-9.])${target_pattern//./\\.}([^0-9.]|$)" <<< "${cleaned_block}" | \
      head -n 1 | \
      sed -E 's/^[[:space:]]*//;s/[[:space:]]*$//'
    )";
    [[ -z "${matched_line}" ]] && return;

    [[ "${verbose}" == true ]] && \
       message "[process_configs] Matched: ${matched_line}";

    #### -----------------------------------------------------------------------
    ## Extract only lines from the block that match the IP pattern
    local -a matched_items=();
    while IFS= read -r line; do
      if grep -Eq "(^|[^0-9.])${target_pattern//./\\.}([^0-9.]|$)" <<< "${line}"; then
        matched_items+=("$(
          sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//' \
          <<< "${line}"
        )");
      fi;
    done <<< "${cleaned_block}";

    local matched_items_json="$(
      printf '%s\n' "${matched_items[@]}" | \
      jq -R . | \
      jq --slurp .
    )";

    #### -----------------------------------------------------------------------
    ## Extract optional description (if present)
    local description_value="$(
      grep -i '^[[:space:]]*description' <<< "${cleaned_block}" | \
      head -n 1 | \
      sed -E 's/^[^"]*"?description"?[[:space:]]*//I; s/^[[:space:]]*//; s/[[:space:]]*$//'
    )";
    [[ -z "${description_value}" ]] && description_value="false";
    [[ "${description_value}" =~ $'\n' ]] && description_value="$( head -n 1 <<< "${description_value}" )";

    [[ "${verbose}" == true ]] && \
       message "[process_configs] Description: ${description_value}";

    #### -----------------------------------------------------------------------
    ## Determine group from matrix (if enabled)
    local group_value="Unclassified";
    if [[ "${classify_targets:-false}" == true ]]; then
      local object_key;
      object_key="$(
        awk '{print $NF}' <<< "${type_value}" | \
        sed -E 's/[[:punct:]]*$//'
      )";
      group_value="$(
        jq -r --arg key "${object_key}" \
                        'map( select( .match[]? | contains( $key ) ) ) | .[0].group' \
        <<< "${matrix_configs}" )";
      if [[ -z "${group_value}" || "${group_value}" == "null" ]]; then
        group_value="$(
          jq -r --arg desc "${description_value}" 'map( select( .match[]? == $desc ) ) | .[0].group' \
          <<< "${matrix_configs}"
        )";
      fi;
      [[ -z "${group_value}" || "${group_value}" == "null" ]] && group_value="Unclassified";
    fi;

    [[ "${verbose}" == true ]] && \
       message "[process_configs] Group: ${group_value}";

    ## -----------------------------------------------------------------------
    ## Convert Bash array data_sets[] to JSON-safe array string
    local items_2json="$(
      printf '%s\n' "${data_sets[@]}" | \
      jq -R . | \
      jq --slurp .
    )";

    #### -----------------------------------------------------------------------
    ## Build sets_json from data_sets[]: summarize first word frequency with debug
    declare -A sets_map;
    for line in "${data_sets[@]}"; do
      [[ -n "${line}" ]] || continue;
      key="$(
        awk '{print $1}' <<< "${line}"
      )";
      [[ -n "${key}" ]] || continue;
      if [[ -z "${sets_map["$key"]+x}" ]]; then
              sets_map["$key"]=1;
        else  (( sets_map["$key"]++ ));
      fi;
    done;

    ## Favoring a more robust JSON construction with jq
    local sets_json="$(
      for k in "${!sets_map[@]}"; do
        printf '{ "key": "%s", "val": %d }\n' "$k" "${sets_map[$k]}"
      done | jq --slurp 'map({(.key): .val}) | add'
    )";

    #### -----------------------------------------------------------------------
    partner_value="";
    case "${object_keyword}" in
      object-group|object ) if [[ "${type_value}" == network* ]]; then
                              extracted_name="${type_value##network }";
                              if ! [[ "${extracted_name}" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
                                partner_value="${extracted_name}";
                              fi;
                            fi;
                            ;;
      * ) partner_value="";
          ;;
    esac;

    #### -----------------------------------------------------------------------
    target_object="$(
      jq -n \
        --arg object "${object_keyword}" \
        --arg type "${type_value}" \
        --arg partner "${partner_value}" \
        --arg description "${description_value}" \
        --argjson items "${matched_items_json}" \
        --argjson sets "${sets_json}" \
        --arg group "${group_value}" \
        '{
          object: $object,
          type: ( $type // false ),
          partner: ( $partner | select(. != "" and . != "null" and . != "false") // false ),
          description: ( $description | select(. != "" and . != "null" and . != "false") // false ),
          items: $items,
          sets: $sets,
          group: $group
        }'
    )";

    ## -------------------------------------------------------------------------- ##
    ## Purpose: `target_object` holds the final structured JSON representation
    ##          of a single matched configuration block.
    ##
    ## Notes:
    ## - It contains all extracted metadata: object type, description, items, sets, data, group.
    ## - It is intended to be collected by `extract_configs()`, NOT written here.
    ## - This variable must be exported only after it's been properly constructed.
    ## - Centralizing the output logic in `extract_configs()` enables proper
    ##   grouping per config file, preserves structure, and prevents flattening.
    ##
    ## Why this matters:
    ## - Writing here would prematurely dump output without associating it to
    ##   a config file — breaking the required `{ config, objects[] }` structure.
    ## - We need `extract_configs()` to be the only function writing grouped output.
    ## -------------------------------------------------------------------------- ##

    export target_object;

    # #### -----------------------------------------------------------------------
    ## Append final JSON object to object_store
    if [[ "${verbose:-false}" == true ]]; then
      message "[process_configs] JSON Object (output):";
      print "${target_object}" | jq .;
      newline;
    fi;

    return 0
}; alias process-configs='process_configs';

#------------------------------------------------------------------------------#
