#!/usr/bin/env bash

## File: scripts/configs-manager.shell

## Prevent re-sourcing and ensure one-time initialization
if [[ -n "${__CONFIGS_MANAGE_SOURCED:-}" ]]; then return 0; fi;
readonly __CONFIGS_MANAGE_SOURCED=1;

## -------------------------------------------------------------------------- ##
## Function: configs-manager :: configs_manager ()
##
## Purpose:
##   Launches background parsing jobs for a batch of target IPs and monitors completion.
##
## Input:
##   None (uses global array: ${target_listing[@]})
##
## Behavior:
##   - Spawns a background job for each IP in `target_listing` using `configs_parser`.
##   - Tracks each job’s PID and associates it with the corresponding IP.
##   - Continuously monitors active jobs, filtering out completed ones.
##   - Waits until all parsing jobs are done before exiting.
##
## Logging:
##   - Logs job start metadata and PID-to-IP mapping to tracking log file.
##   - Optionally logs job completion (currently commented out).
##
## Notes:
##   - This function is always run synchronously — no nested async logic inside configs_parser.
##   - Designed to be called once per config batch within inner loop.
## -------------------------------------------------------------------------- ##

function configs_manager () {

    #### -----------------------------------------------------------------------
    local configs_parser__script="configs-parser";

    declare -a parser_jobs_pid=();          ## Array to hold the PIDs of background jobs
    declare -A parser_jobs2ips_mapping=();  ## Associative array to map PIDs to IPs

    ip_index=0;
    local total_ips=${#target_listing[@]};

    #### -----------------------------------------------------------------------
    local configs_parser__logfile="${TMP_DIR}/configs-parser.logs";
    :> "${configs_parser__logfile}";

    mkdir -p "${jobs_location}" 2>/dev/null || true;

    while (( ip_index < total_ips )); do

      ip_address="${target_listing[ip_index++]}";
      padded_index="$(
        printf "%0${#total_ips}d" "${ip_index}"
      )";

      local configs_parser__logger="${TMP_DIR}/${configs_parser__script}--${ip_address}";
      : > "${configs_parser__logger}";

      declare -a execute__configs_parser=(
        configs_parser
        --configs="${reports_location}/${ip_address}"
        --ip-addr="${ip_address}"
        --index="${padded_index}"
        --matrix="${matrix_filename}"
        --reports="${reports_location}"
        --file-ext="$(
          IFS=,; print "${file_extensions[*]}"
        )"
        --logger="${configs_parser__logger}.console"
      );

      [[ "${classify_targets}" == true ]] && execute__configs_parser+=( --classify );
      [[ "${validate_address}" == true ]] && execute__configs_parser+=( --validate );
      [[ "${verbose}" == true ]] && execute__configs_parser+=( --verbose );
      [[ "${verbose}" == true ]] && execute__configs_parser+=( --debug );

      #### -----------------------------------------------------------------------
      ## Execute and propagate exit status
      if [[ "${verbose}" == true ]]; then
        {
          message "Parsing Configs: [ ${ip_address} ]";
          for parameter in "${execute__configs_parser[@]}"; do
            message "\t\t${parameter}";
          done;
          newline;
        } >> "${configs_manager__console:-/dev/null}";
      fi;

      (

        local status=0;
        local module_logfile="${jobs_location}/${configs_parser__script}/${ip_address}.job";

        mkdir -p $( dirname "${module_logfile}" ) 2>/dev/null || true;
        :> "${module_logfile}";  ## Clear the log file if it exists
        # "${execute__configs_parser[@]}" >> "${jobs_location:-/dev/null}.log" 2>&1;

        # if (( status != 0 )); then
        #         {
        #           warning "Failed to process IP [ ${search_pattern} ] configs :: exit ${status}";
        #         } >> "${target_logfile:-/dev/null}";
        #   else  {
        #           message "Parsed IP Address: [ ${search_pattern} ] configs :: exit ${status}";
        #         } >> "${target_logfile:-/dev/null}";
        # fi;

      ) &

      local job_pid=$!;
      parser_jobs_pid+=( "${job_pid}" );
      parser_jobs2ips_mapping["$job_pid"]="${ip_address}";

    done;

    #### -----------------------------------------------------------------------
    ## Wait for all jobs to finish
    while (( ${#parser_jobs_pid[@]} > 0 )); do
      local valid_parser_jobs_pid=();
      for pid in "${parser_jobs_pid[@]}"; do
        if ! kill -0 "${pid}" 2>/dev/null; then
                ## Job finished — no action here
                logger="${parser_jobs2ips_mapping[$pid]}";
          else  valid_parser_jobs_pid+=( "${pid}" );
        fi;
      done;
      parser_jobs_pid=( "${valid_parser_jobs_pid[@]}" );
      sleep "${delaying_factor}";
    done;

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        message "Background Jobs -> Managed Configs:";
        message "PID   | IP Address (${#parser_jobs2ips_mapping[@]})";
        message "-------------------------";
        for pid in "${!parser_jobs2ips_mapping[@]}"; do
          printf "%-5s | %s\n" "${pid}" "${parser_jobs2ips_mapping[$pid]}";
        done;
        newline;
      } >> "${configs_manager__console:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    ## Collecting all background-jobs console outputs
    {
      for pid in "${!parser_jobs2ips_mapping[@]}"; do
        ip_address="${parser_jobs2ips_mapping[${pid}]}";
        parser_config="${reports_location}/${ip_address}.json";
        if [[ -s "${parser_config}" && -f "${parser_config}" ]]; then
          message "Completed Background Jobs (Managed Configs): ${parser_config}";
          jq -r . "${parser_config}" || warning "Invalid JSON: ${parser_config}";
          newline;
        fi;
      done;
    } >> "${configs_manager__console}";

    return 0;
}; alias configs-manager='configs_manager';

#------------------------------------------------------------------------------#
