#!/usr/bin/env bash

## -------------------------------------------------------------------------- ##
## File: scripts/extract-configs.shell
##
## Purpose:
##   Extracts targeted configuration blocks from vendor-native network
##   configuration files (e.g., Cisco, Fortinet) using platform-specific
##   AWK reducers. Designed for use as a high-speed preprocessing engine.
##
## Overview:
##   - Accepts a config file and a search pattern (IPs, names, etc).
##   - Detects platform automatically (or accepts it via --platform).
##   - Dispatches to: ./scripts/extract/<vendor>-configs.awk
##   - Outputs reduced config to file (--extract) or to console (--console).
##   - Fully traceable via verbose logs.
##
## Usage:
##   bash ./scripts/extract-configs.shell \
##     --search=10.0.0.1 \
##     --config=configs/fw-1.cfg \
##     --extract=./tmp/fw1-reduced.cfg \
##     [--platform=cisco|fortinet] \
##     [--console] \
##     [--verbose]
##
## Requirements:
##   - Bash v4+, GNU awk, grep, sed
##   - ./scripts/extract/<vendor>-configs.awk must exist
##
## Notes:
##   - Never embed vendor-specific parsing logic in this script.
##   - This script is called by network-configs.shell as a subroutine.
##   - Designed for compatibility with JSON-ready parsing workflows.
##
## -------------------------------------------------------------------------- ##

set -euo pipefail  ## Strict mode: exit on error, undefined var use, and pipeline failure
# set -x;          ## Enable for execution tracing/debugging

## POSIX locale standard
export LC_ALL=C   ## Ensure consistent sorting and character handling (POSIX-compliant)

# Create a secure, temporary working directory (auto-cleaned at script exit)
export TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

export nl="\n";

#------------------------------------------------------------------------------#
function display_help () {
    local -a help_lines=();
    local indent="    ";
    local padding="$( printf '%*s' ${#script_name} ' ' )";
    ## Header
    help_lines+=( "Usage: ${script_name} [OPTIONS]${nl}" );
    ## Shared Options
    help_lines+=( "Options:${nl}" );
    help_lines+=( "  -i, --ips-list     Custom Search Pattern: IP Address, etc." );
    help_lines+=( "  -c, --config       Source Configuration filepath to be parsed" );
    help_lines+=( "  -o, --output       Output Filepath for extracted datasets (*.cfg)" );
    help_lines+=( "  -p, --platform     Provide platform-specific config (cisco, fortinet)" );
    help_lines+=( "${nl}" );
    ## Flags
    help_lines+=( "Flags:${nl}" );
    help_lines+=( "  --help             Show this help message and exit" );
    # help_lines+=( "  --debug            Enable debug mode with trace output" );
    # help_lines+=( "  --dry-run          Print actions without executing them" );
    help_lines+=( "  --verbose          Enable verbose output${nl}" );
    ## Output
    newline;
    for line in "${help_lines[@]}"; do
      message "${indent}${line}";
    done;
    # return 0;
}; alias display-help='display_help';

#------------------------------------------------------------------------------#
## Output Utilities: Print N newlines (default: 1)
function newline () {
    local count="${1:-1}";
    for ((i = 0; i < count; i++)); do echo; done;
    # return 0;
}; alias new-line='newline';

#------------------------------------------------------------------------------#
## Output Utilities: Print an error message in consistent format
function message () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -e "${message}";
    # return 0;
}; alias print-message='message';

#------------------------------------------------------------------------------#
## Output Utilities: Print a message (no-newline) in consistent format
function print () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -en "${message}";
    # return 0;
  }; alias print-inline='print';

#------------------------------------------------------------------------------#
## Output Utilities: Print an error message in consistent format
function warning () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -e "Warning: ${message}";
    # return 0;
}; alias error-message='warning';

#------------------------------------------------------------------------------#
function detect_vendor () {
    local config_file="${1}";
    local fortinet_pattern='fortinet|fortigate';
    local cisco_pattern='\basa\b|cisco ios|cisco adaptive|^interface\b|^object\b';
    if grep -qiE "${fortinet_pattern}" "${config_file}"; then
            return 1;
      elif  grep -qiE "${cisco_pattern}" "${config_file}" 2>/dev/null; then
            return 2;
      else  return 3;
    fi;
    # return 0;
}; alias detect-vendor='detect_vendor';

#------------------------------------------------------------------------------#
function main () {
    ## tracking_process ${FUNCNAME} "${@}";
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(config|c)$ ]] && local target_config="${value}";
      [[ $key =~ ^(console|o)$ ]] && local console_output=true;
      [[ $key =~ ^(extract|x)$ ]] && local extract_location="${value}";
      [[ $key =~ ^(platform|p)$ ]] && local target_platform="${value}";
      [[ $key =~ ^(search|s)$ ]] && local search_pattern="${value}";

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && local debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true;
    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied
    [[ -z ${debug:-} ]] && debug=false;
    [[ -z ${dry_run:-} ]] && dry_run=false;
    [[ -z ${verbose:-} ]] && verbose=false;

    #### -----------------------------------------------------------------------
    [[ -z "${console_output:-}" ]] && export console_output=false;

    #### -----------------------------------------------------------------------
    ## Display usage help if requested
    [[ -z ${script_helper:-} ]] && script_helper=false;
    if [[ ${script_helper:-} == true ]]; then
      display_help;
      exit 0;
    fi;

    #### -----------------------------------------------------------------------
    ## Prompt for search pattern if not provided
    local prompt_message="Enter search pattern (IP address, CIDR, etc.): ";
    while [[ -z "${search_pattern}" ]]; do
      newline;
      read -e -p "${prompt_message}" search_pattern;
      if [[ "${search_pattern// /}" == "" ]]; then
        warning "Search pattern is required.";
        search_pattern=false;
        return 1;
      fi;
    done;

    #### -----------------------------------------------------------------------
    ## Normalize search pattern input into search_terms[]
    declare -a search_terms=();

    if [[ -f "${search_pattern}" && "${search_pattern}" != *,* ]]; then
            ## Read IPs from file
            mapfile -t search_terms < <(
              tr -d '\r' < "${search_pattern}" | \
              grep -v '^\s*$' | grep -v '^#'
            );
      else  ## Inline string â€” preserve full IPs and split only on clear delimiters
            IFS=$'\n' read -r -d '' -a search_terms <<< "$(
              echo "${search_pattern}" | \
              sed 's/[][|;:]/ /g' | tr ', ' '\n\n' | \
              grep -v '^\s*$'
            )" || true;
            ## Write to temp file
            search_pattern="${TMP_DIR}/ips.list";
            printf "%s\n" "${search_terms[@]}" > "${search_pattern}";
    fi;

    #### -----------------------------------------------------------------------
    ## Compact form of targets for logging (first and last elements only)
    local first_search_entry="${search_terms[0]}"
    local last_search_entry="${search_terms[-1]}"
    local target_search_range="${first_search_entry}, ... ,${last_search_entry}"

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        newline;
        message "Search Pattern: [ ${search_pattern} ]";
        local count=${#search_terms[@]};
        if (( count == 0 )); then
                warning "No search terms provided or extracted.";
          else  print "Search Terms (${count}): ";
                print "[ ${target_search_range} ]"

        fi;
        newline;
      } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    ## Prompt for source configuration file if not provided
    local prompt_message="Enter configuration file to be parsed: ";
    while [[ -z "${target_config:-}" ]]; do
      newline;
      read -e -p "${prompt_message}" target_config;
      if [[ -z "${target_config}" || ! -f "${target_config}" || ! -r "${target_config}" ]]; then
        warning "Provided file [ ${target_config:-} ] does not exist or is not readable.";
        target_config="";
        continue;
      fi;
    done;

    #### -----------------------------------------------------------------------
    if [[ -z "${target_platform:-}" ]]; then
      set +e;
      detect_vendor "${target_config}";
      local vendor_code=${?};
      set -e;
      case "${vendor_code}" in
        1)  target_platform="fortinet";
            ;;
        2)  target_platform="cisco";
            ;;
        3)  target_platform="unknown";
            {
              warning "Unsupported configuration type: ${target_config}";
              newline 2;
            } >> "${trace_logfile:-/dev/null}";
            return 1;
            ;;
        *)  target_platform="unknown";
            {
              warning "Unknown configuration type: ${target_config}";
              newline 2;
            } >> "${trace_logfile:-/dev/null}";
            return 1;
            ;;
      esac;

    fi;

    #### -------------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        newline;
        message "Target Config: [ ${target_config} ] ( ${target_platform} )";
        ls -al --color=auto "${target_config}" 2>/dev/null;
      } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -------------------------------------------------------------------------
    ## Extraction path resolution (optional, silent if unset)
    if [[ -n "${extract_location:-}" ]]; then
            if [[ "${extract_location##*.}" == "${target_config##*.}" ]]; then
                    ## If same extension as source, treat as direct file path
                    final_output="${extract_location}";
              else  ## Otherwise treat as a base directory and replicate source path inside
                    base_output="${extract_location%/}";
                    rel_path="$( echo "${target_config}" | sed 's|^\./||' )";
                    final_output="${base_output}/${rel_path}";
            fi;
            extract_location="${final_output}";
            output_dir="$( dirname "${extract_location}" )";
            if [[ ! -d "${output_dir}" ]]; then
              mkdir -p "${output_dir}" || {
                  message "Warning: Failed to create output directory: ${output_dir}" >&2
                  newline;
              };
            fi;
      else  {
              warning "Skipping step to export the extracted configuration.";
            } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    ## Resolve the real path of this script
    local SCRIPT_PATH="$(
      command -v -- "${BASH_SOURCE[0]}"
    )";
    local SCRIPT_DIR="$(
      dirname -- "${SCRIPT_PATH}"
    )";

    ## Locate vendor-specific AWK parser
    local script_filename="${target_platform}-configs.awk";
    local script_filepath="${SCRIPT_DIR}/extract/${script_filename}";

    ## Validate presence of the AWK script
    if [[ ! -f "${script_filepath}" ]]; then
      {
        warning "AWK script '${script_filename}' was not found [ ${target_platform} ]";
        message "Expected path: ${script_filepath}";
        newline;
      } >> "${trace_logfile:-/dev/null}";
      return 1;
    fi;

    # #### -----------------------------------------------------------------------
    # local extracted_configuration="$(
    #   $( which awk ) -v targets="${search_pattern}" \
    #                  -f "${script_filepath}" \
    #                     "${target_config}" \
    #   ;
    # )";
    # result=$?;
    # # message "AWK exit code: ${result}";

    #### -----------------------------------------------------------------------
    ## Prepare AWK command
    declare -a execute=(
      $(which awk)
      -v "targets=$( IFS=','; echo "${search_terms[*]}" )"
      -f "${script_filepath}"
      "${target_config}"
    );

    local awk_bin="$( which awk )";
    local awk_args="-v targets=\"${target_search_range}\"";
    local base_cmd="${awk_bin} ${awk_args}";

    # Calculate indent based on the length of base_cmd
    local indent=$( printf '%*s' "${#awk_bin}" '' );

    #### -----------------------------------------------------------------------
    ## Log execution if verbose
    if [[ "${verbose}" == true ]]; then
      {
        newline;
        message "Executing AWK script [ ${script_filepath} ]";
        message "${base_cmd} \\";
        message "${indent} -f ${script_filepath} \\";
        message "${indent}    ${target_config}";
        newline;
      } >> "${trace_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    ## Execute and capture output
    local extracted_configuration="$( "${execute[@]}" 2>&1 )";
    result=$?;

    #### -----------------------------------------------------------------------
    if [[ -n "${extracted_configuration}" ]]; then

            # print "${extracted_configuration}" > "${extract_location}";
            print "${extracted_configuration}" | \
            sed '1{/^[[:space:]]*$/d;}' \
            > "${extract_location}";
            newline 2 >> "${extract_location}";

            if [[ "${verbose}" == true ]]; then
              {
                message "Configuration File [ ${extract_location} ]";
                newline;
                cat -n "${extract_location}";
              } >> "${trace_logfile:-/dev/null}";
            fi;

            if [[ "${console_output}" == true ]]; then
              {
                message "Extracted Configuration:";
                newline;
                print "${extracted_configuration}" | \
                sed '1{/^[[:space:]]*$/d;}';
              };
            fi;

      else  {
              warning "No matching blocks were found. Output to file was not written.";
              newline;
            } >> "${trace_logfile:-/dev/null}";
            return 1;

    fi;

    # return 0;
}; alias parse-cisco='main';

#------------------------------------------------------------------------------#

[[ -z "${script_name+x}" ]] && export script_name="${0}";

export logs_location="logs";
mkdir -p ${logs_location}/console 2>/dev/null || true;

script_filename="${BASH_SOURCE[0]##*/}";
script_filename="${script_filename%.*}";

trace_logfile="${logs_location}/console/${script_filename}.console";
touch "${trace_logfile}";

#------------------------------------------------------------------------------#

if [[ ${#@} -eq 0 || "${1,,}" =~ ^-*(h|help)$ ]]; then
        main --help ;
  else  main "${@}";
        result=${?}; exit ${result};
        ## newline; message "Done."; newline;
fi;

## -------------------------------------------------------------------------- ##
## Examples:
##
## 1. Extract from Cisco config using IP matches:
##    bash scripts/extract-configs.shell \
##         --search="10.0.0.1,192.168.1.1" \
##         --config=./configs/core-fw.cfg \
##         --extract=./reduced/core-fw.cfg \
##         --platform=cisco
##
## 2. Extract from Fortinet config using VPN object names:
##    bash scripts/extract-configs.shell \
##         --search="edit VPN-PROFILE,edit BRANCH-ACCESS" \
##         --config=./configs/fg-dmz.cfg \
##         --extract=./reduced/fg-dmz.cfg \
##         --platform=fortinet
##
## 3. Auto-detect platform from config content:
##    bash scripts/extract-configs.shell \
##         --search="permit ip any" \
##         --config=./configs/asa-fw.cfg \
##         --extract=./reduced/asa-fw.cfg
##
## 4. Display output to console instead of writing to file:
##    bash scripts/extract-configs.shell \
##         --search="10.1.1.1" \
##         --config=./configs/switch.cfg \
##         --console
##
## 5. Run interactively (prompts for search/config/platform):
##    bash scripts/extract-configs.shell
##
## Notes:
##   - The --search string is passed directly to the AWK script.
##   - Use --platform to override automatic detection.
##   - Use --console to display output without writing to disk.
## -------------------------------------------------------------------------- ##
