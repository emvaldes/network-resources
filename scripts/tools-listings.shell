#!/usr/bin/env bash

## File: scripts/tools-listings.shell

## Prevent re-sourcing and ensure one-time initialization
if [[ -n "${__TOOLS_LISTINGS_SOURCED:-}" ]]; then return 0; fi;
readonly __TOOLS_LISTINGS_SOURCED=1;

#### ---------------------------------------------------------------------------
# JSON generation function: Handles file matching and creates the JSON output
function generate_configslist () {

    local ip_addr="$1";
    local target_file="$2";

    local source_configs_list="${3:-${configs_list_cache}}";
    # message "[generate_configslist] Configurations File: ${source_configs_list}";

    ## Match configuration files for the current IP address

    local matched_files=$(
      grep -lE "(^|[^0-9.])${ip_addr//./\\.}([^0-9.]|$)" \
               $( <"${source_configs_list}" ) 2>/dev/null || true
    );

    # declare -a matched_files=($(
    #   cat "${source_configs_list}"
    # ));
    # print "Matched files: ${matched_files}"

    ## If matched files exist, generate the JSON structure
    if [[ -n "${matched_files}" ]]; then
      ## Initialize an empty JSON array
      config_json="[]";

      ## Iterate through matched files and prepare JSON entries
      while IFS= read -r config_file; do
        ## Remove the "configs_dirpath" prefix from each file path

        # config_file=$(
        #   print "${config_file}" | \
        #   sed "s|^${configs_dirpath}/||"
        # );
        ## Strip full prefix before storing to JSON
        config_file="${config_file#"${configs_dirpath%/}/"}";

        ## Count the number of lines in the config file
        config_lines=$(
          wc -l < "${configs_dirpath}/${config_file}"
        );
        ## Count how many times the IP appears in the config file
        match_count=$(
          grep -oE "(^|[^0-9.])${ip_addr//./\\.}([^0-9.]|$)" \
                   "${configs_dirpath}/${config_file}" | \
          wc -l | tr -d ' '
        );
        ## Extracting target Site and Device items
        site="${config_file%%/*}"
        device="${config_file#*/}"
        ## Generate JSON entry for the current file and append it to the JSON array
        config_json=$(
          print "${config_json}" |
          jq --arg site "${site}" \
             --arg device "${device}" \
             --argjson lines "${config_lines}" \
             --argjson count "${match_count}" \
             '. += [ { "config": { "site": $site, "device": $device }, "lines": $lines, "count": $count } ]'
        )
      done <<< "${matched_files}";

      ## Wrap the array into the final structure with {configs: $configs}
      final_json=$(
        print "${config_json}" | jq '{ configs: . }'
      );
      ## Save the final JSON to the target file
      jq -r <<< "${final_json}" > "${target_file}";

      ## Log the generation of the JSON file
      {
        message "Generated Config-File: ${target_file}";
        # print_file "${target_file}";
      } >> "${targets_logsfile}";

    fi;
    return 0;
}; alias generate-configslist='generate_configslist';

#### ---------------------------------------------------------------------------
# Function: generate_csvoutput
# Purpose: Converts all per-IP JSON files into a single CSV output (stream-based).

function generate_csvoutput () {

    local tmp_csv="$( mktemp )";  ## Temporary file for accumulating unsorted CSV rows

    ## Ensure JSON directory exists and contains files
    if [[ ! -d "${reports_folder}" ]]; then
      error_message "Missing ${reports_folder}, cannot generate CSV.";
      return 1;
    fi;

    find "${reports_folder}" \
         -type f \
         -name '*.json' \
         -mindepth 2 \
         -maxdepth 2 | \
    sort | \
    while read -r json; do
        message "Processing ${json}" >&2;
        jq_json2csv='.target as $target
                    | .configs[]
                    | select( .objects != null and ( .objects | type == "array" and length > 0 ) )
                    | .objects[] as $obj
                    | [
                        $target,
                        ( .site // "none" ),
                        ( .device // "none" ),
                        ( $obj.object // "none" ),
                        ( $obj.items[0] // "none" ),
                        ( $obj.description // "none" ),
                        ( $obj.group // "none" )
                      ]
                    | @csv';

        ## Strategy: Ensures progress is persisted incrementally and not lost on failure
        ##           Ideal for long-running jobs or unstable environments
        ##           Rows are written directly to the shared ./reports/reports.csv
        jq -e -r "${jq_json2csv}" "${json}" >> "${tmp_csv}" \
        || message "[WARN] Failed CSV append for ${json}" >&2;

    done;

    ## Sort the CSV (preserve header)
    {
      message "target,site,device,object,sets,description,group";
      sort -t',' -k1,1 -k2,2 -k3,3 -k4,4 "${tmp_csv}";
    } > "${output_csv}" && rm -f "${tmp_csv}";

    return 0;
}; alias generate-csvoutput='generate_csvoutput';

#### ---------------------------------------------------------------------------
# Main function: Manages the background jobs and waits for them to complete
function manage_configs () {

    declare -a configs_jobs_pid=();    ## Array to hold the PIDs of background jobs
    declare -A configs_jobs2ips_mapping=();  ## Associative array to map PIDs to IPs

    ip_index=0;
    total_ips=${#target_listing[@]};

    while (( ip_index < total_ips )); do
      ip_addr="${target_listing[ip_index++]}";
      padded_index="$(
        printf "%0${#total_ips}d" "${ip_index}"
      )";
      (
        parse_configs "${ip_addr}" "${padded_index}"
      ) &
      job_pid=$!;
      configs_jobs_pid+=( "${job_pid}" );
      configs_jobs2ips_mapping["$job_pid"]="${ip_addr}";
      # message "[INFO] Started Managed-Configs (${job_pid}): ${ip_addr}" \
      #       >> "${started_logsfile}";
      # list_file "${started_logsfile}";
    done;
    # newline >> "${started_logsfile}";

    {
      message "Background Jobs -> Managed Configs:";
      message "PID   | IP Address (${#configs_jobs2ips_mapping[@]})";
      message "-------------------------";
      for pid in "${!configs_jobs2ips_mapping[@]}"; do
        printf "%-5s | %s\n" "${pid}" "${configs_jobs2ips_mapping[$pid]}";
      done;
      newline;
    } >> "${actions_logsfile}";

    ## Monitor background jobs
    while (( ${#configs_jobs_pid[@]} > 0 )); do
      valid_configs_jobs_pid=();
      for pid in "${configs_jobs_pid[@]}"; do
        if ! kill -0 "$pid" 2>/dev/null; then
                ip="${configs_jobs2ips_mapping[$pid]}"
                # message "[INFO] Completed ($pid): ${ip}" >> "${success_logsfile}";
          else  valid_configs_jobs_pid+=( "$pid" );
        fi;
      done;
      configs_jobs_pid=( "${valid_configs_jobs_pid[@]}" );
      sleep 0.5;
    done;
    return 0;
}; alias manage-configs='manage_configs';

#### ---------------------------------------------------------------------------
# Main function: Manages the background jobs and waits for them to complete
function matching_configs () {

    local input_parameter="PARAMETER";
    local source_configs_list="${1:-${configs_list_cache}}";

    declare -ga targets_jobs_pid=();          ## Array to hold the PIDs of the background jobs
    declare -gA targets_jobs2ips_mapping=();  ## Associative array to map PIDs to IPs

    {
      message "[EXECUTE]   ${FUNCNAME}";
      message "[PARAMETER] source_configs_list:\n   $(
        printf '%*s' "${#input_parameter}"
      )${source_configs_list}";
      # print_file "${source_configs_list}";
      newline;
    } >> "${actions_logsfile}";

    # Build IP lookup set and output map
    declare -A targets=();
    declare -A ip2files=();

    for ip in "${target_listing[@]}"; do
      targets["$ip"]=1;
      ip2files["$ip"]="";
    done;

    # Read all matching lines at once
    mapfile -t matched_lines < <(
      grep -HF -f "${target_addresses}" $( <"${source_configs_list}" )
    );

    # Flat, single-pass assignment
    for line in "${matched_lines[@]}"; do
      file="${line%%:*}";
      entry="${line#*:}";
      # Tokenize IPs in this line (not scanning target list)
      for token in $(grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' <<< "$entry"); do
        [[ ${targets["$token"]+x} ]] || continue;
        current="${ip2files[$token]}";
        [[ ":$current:" == *":$file:"* ]] && continue;
        ip2files["$token"]+="${current:+":"}$file";
      done;
    done;

    # {
    #   message "Matched IPs to [${site}] configs:";
    #   message "------------------------------------";
    #   for ip in "${!ip2files[@]}"; do
    #     [[ -n "${ip2files[$ip]}" ]] || continue;
    #     # printf "%-15s => %s\n" "$ip" "${ip2files[$ip]}";
    #     shortened_files="$( sed "s|${configs_dirpath}/${site}/||g" <<< "${ip2files[$ip]}" )";
    #     printf "%-15s => %s\n" "$ip" "${shortened_files}";
    #   done;
    #   newline;
    # } >> "${actions_logsfile}";

    # Overwrite target_listing with filtered IPs that had matches
    target_listing=();
    for ip in "${!ip2files[@]}"; do
      [[ -n "${ip2files[$ip]}" ]] && target_listing+=( "$ip" );
    done;

    ## Flatten and deduplicate matched files into the source_configs_list
    {
      for ip in "${!ip2files[@]}"; do
        [[ -n "${ip2files[$ip]}" ]] || continue;
        tr ':' '\n' <<< "${ip2files[$ip]}"
      done | sort -u;
    } > "${source_configs_list}"

    ## Iterate over filtered and cleaned target IP addresses
    for ip_addr in "${target_listing[@]}"; do
      target_file="targets/${ip_addr}.json";
      (
        generate_configslist "${ip_addr}" \
                             "${target_file}" \
                             "${source_configs_list}";
      ) &

      job_pid=$!;
      targets_jobs_pid+=( "${job_pid}" );
      targets_jobs2ips_mapping["${job_pid}"]="${ip_addr}";
    done;

    # {
    #   message "Background Jobs/IPs Matrix:";
    #   message "PID   | IP Address (${#targets_jobs2ips_mapping[@]})";
    #   message "-------------------------";
    #   for pid in "${!targets_jobs2ips_mapping[@]}"; do
    #     printf "%-5s | %s\n" "${pid}" "${targets_jobs2ips_mapping[$pid]}";
    #   done;
    #   newline;
    # } >> "${actions_logsfile}";

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        message "Matched IPs to [${site}] configs (${#targets_jobs2ips_mapping[@]}):";
        message "-------------------------------------";
        message "PID    | IP Address      => Config(s)";
        message "-------------------------------------";
        for pid in "${!targets_jobs2ips_mapping[@]}"; do
          ip="${targets_jobs2ips_mapping[$pid]}";
          config_raw="${ip2files[$ip]:-none}";
          config_cleaned="$(
            sed "s|${configs_dirpath}/${site}/||g" <<< "${config_raw}"
          )";
          printf "%-6s | %-15s => %s\n" "$pid" "$ip" "$config_cleaned";
        done;
        newline;
      } >> "${actions_logsfile}";
    fi;

    ## Monitor the background jobs until all are completed
    while (( ${#targets_jobs_pid[@]} > 0 )); do
      valid_targets_jobs_pid=();
      for pid in "${targets_jobs_pid[@]}"; do
        if ! kill -0 "$pid" 2>/dev/null; then
                ## Job completed
                ip_address="${targets_jobs2ips_mapping[$pid]}"  ## Retrieve the IP associated with this job PID
                # message "[INFO] Completed ($pid): ${ip_address}" >> "${success_logsfile}";
          else  valid_targets_jobs_pid+=( "$pid" );  ## Job still running
        fi;
      done;
      targets_jobs_pid=( "${valid_targets_jobs_pid[@]}" );
      sleep 0.5  # Short delay to prevent excessive CPU usage
    done;

    return 0;
}; alias matching-configs='matching_configs';

#### ---------------------------------------------------------------------------
# Function: run_config_parser
# Purpose: Executes parse-configs.shell for a single IP address
# Input:
#   $1 = IP address
#   $2 = padded index

## WARNING: This function is executed as a background job from manage_configs()
##          Do not introduce inner '&' or nested asynchronous calls.
##          Keep all processing synchronous to retain job PID tracking.

function parse_configs () {
    local ip_addr="${1}";
    local padded_index="${2}";
    execute=(
      ./scripts/parse-configs.shell
      --configs="${configs_dirpath}"
      --ip-addr="${ip_addr}"
      --index="${padded_index}"
      --matrix="${matrix_filename}"
      --reports="${reports_folder}"
      --file-ext="$(
        IFS=,; print "${file_extensions[*]}"
      )"
    );
    [[ "${classify_targets}" == true ]] && execute+=( --classify );
    [[ "${validate_address}" == true ]] && execute+=( --validate );
    [[ "${verbose}" == true ]] && execute+=( --verbose );
    [[ "${debug}" == true ]] && execute+=( --debug );
    if [[ "${enable_logging:-}" == true ]]; then
            mkdir -p "${local_state_dir}/jobs" "${local_state_dir}/errors";
            logfile="${local_state_dir}/jobs/${ip_addr}.job";
            if [[ "${debug}" == true ]]; then
                    bash -x "${execute[@]}" > "${logfile}" 2>&1;
              else  "${execute[@]}" > "${logfile}" 2>&1;
            fi;
            # list_file "${logfile}";
      else  if [[ "${debug}" == true ]]; then
                    bash -x "${execute[@]}" >/dev/null 2>&1;
              else  "${execute[@]}" >/dev/null 2>&1;
            fi;
    fi;
    local status=$?;
    if (( status != 0 )); then
            errors_logfile="${local_state_dir}/errors/errors.log";
            {
              message "[ERROR] IP: ${ip_addr} failed :: exit ${status}";
              message "  See: ${logfile}";
            } >> "${errors_logfile}";
            # list_file "${errors_logfile}";
      # else  message "[DONE] IP: ${ip_addr}" >> "${reports_logsfile}";
      #       # list_file "${reports_logsfile}";
    fi;
    return "${status}";
}; alias parse-configs='parse_configs';

#------------------------------------------------------------------------------#
