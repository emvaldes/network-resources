#!/usr/bin/env bash

## File: scripts/extract-fortinet.shell

## Purpose: Parse a set of IP addresses against a directory of configuration files
##          and produce detailed per-IP reports in JSON and CSV format.
## Requirements: Bash v4+ and GNU utilities (jq, find, grep, sed, etc.)

## > bash ./scripts/extract-fortinet.shell \
##     --ip-addr|-i \
##     --config=config.cfg \
##     --output=output.cfg \
##     --verbose ;

set -euo pipefail  ## Strict mode: exit on error, undefined var use, and pipeline failure
# set -x;          ## Enable for execution tracing/debugging

## POSIX locale standard
export LC_ALL=C   ## Ensure consistent sorting and character handling (POSIX-compliant)

# Create a secure, temporary working directory (auto-cleaned at script exit)
export TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

export nl="\n";

#------------------------------------------------------------------------------#
function display_help () {
    local -a help_lines=();
    local indent="    ";
    local padding="$( printf '%*s' ${#script_name} ' ' )";
    ## Header
    help_lines+=( "Usage: ${script_name} [OPTIONS]${nl}" );
    ## Shared Options
    help_lines+=( "Options:${nl}" );
    help_lines+=( "  -i, --ip-addr      Custom Search Pattern: IP Address, etc." );
    help_lines+=( "  -c, --config       Source Configuration filepath to be parsed" );
    help_lines+=( "  -o, --output       Output Filepath for extracted datasets (*.cfg)" );
    help_lines+=( "${nl}" );
    ## Flags
    help_lines+=( "Flags:${nl}" );
    help_lines+=( "  --help             Show this help message and exit" );
    # help_lines+=( "  --debug            Enable debug mode with trace output" );
    # help_lines+=( "  --dry-run          Print actions without executing them" );
    help_lines+=( "  --verbose          Enable verbose output${nl}" );
    ## Output
    newline;
    for line in "${help_lines[@]}"; do
      message "${indent}${line}";
    done;
    return 0;
}; alias display-help='display_help'

#------------------------------------------------------------------------------#
## Output Utilities: Print N newlines (default: 1)
function newline () {
    local count="${1:-1}";
    for ((i = 0; i < count; i++)); do echo; done;
    # return 0;
}; alias new-line='newline';

#------------------------------------------------------------------------------#
## Output Utilities: Print an error message in consistent format
function message () {
    [[ -n ${1:-} ]] && local message="${1}" || return 0;
    echo -e "${message}";
    return 0;
}; alias print-message='message';

#------------------------------------------------------------------------------#
function main () {
    ## tracking_process ${FUNCNAME} "${@}";
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(ip-addr|i)$ ]] && export search_pattern="${value}";
      [[ $key =~ ^(config|c)$ ]] && export source_config="${value}";
      [[ $key =~ ^(output|o)$ ]] && export output_config="${value}";

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && local debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true;
    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied
    [[ -z ${script_helper:-} ]] && script_helper=false;
    [[ -z ${debug:-} ]] && debug=false;
    [[ -z ${dry_run:-} ]] && dry_run=false;
    [[ -z ${verbose:-} ]] && verbose=false;

    #### -----------------------------------------------------------------------
    ## Display usage help if requested
    if [[ ${script_helper:-} == true ]]; then
      display_help;
      exit 0;
    fi;

    #### -----------------------------------------------------------------------
    while [[ -z ${search_pattern:-} ]]; do
      newline;
      read -e -p "Enter target search pattern: " search_pattern
      if [[ "${search_pattern:-}" =~ ^[[:space:]]*$ ]]; then
        message "Warning: Pattern cannot be empty!" >&2;
        newline;
        exit 1;
      fi;
    done;

    #### -----------------------------------------------------------------------
    while [[ -z ${source_config:-} || ! -f "${source_config}" ]]; do
      newline;
      read -e -p "Enter source configuration file: " source_config;
      if [[ ! -f "${source_config}" ]]; then
        message "Warning: File does not exist!" >&2;
        newline;
        exit 2;
      fi;
    done;
    if ! grep -qiE 'fortinet|fortigate' "${source_config}"; then
      message "Warning: This does not appear to be a Fortinet configuration!" >&2;
      newline 2;
      exit 3;
    fi;

    #### -----------------------------------------------------------------------
    while [[ -z ${output_config:-} ]]; do
      newline;
      read -e -p "Enter output configuration file: " output_config;
    done
    local output_dir="$( dirname "${output_config}" )";
    if [[ ! -d "${output_dir}" ]]; then
      mkdir -p "${output_dir}" || {
        message "Warning: Failed to create output directory: ${output_dir}" >&2;
        newline;
        exit 4;
      };
    fi;

    #### -----------------------------------------------------------------------
    ## Optionally: echo resolved parameters
    # newline;
    # message "Serach Pattern: ${search_pattern}";
    # message "Input Config:   ${source_config}";
    # message "Output Config:  ${output_config}";
    # newline;

    #### -----------------------------------------------------------------------
    ## This is an Artificial Intellingence Asssisted contribution:
    local extracted_configuration="$(
      awk -v target="${search_pattern}" '
      BEGIN {
        in_config = 0;
        in_edit = 0;
        config_header = "";
        edit_block = "";
        match_found = 0;
        collected_edits = "";
        headers = "";
        headers_done = 0;
        output = "";
      }
      /^#/ {
        headers = headers $0 "\n";
        next;
      }
      /^config / {
        if (in_config && length(collected_edits) > 0) {
          output = output config_header "\n" collected_edits "end\n\n";
        }
        config_header = $0;
        in_config = 1;
        collected_edits = "";
        next;
      }
      /^ edit / {
        if (in_edit && match_found) {
          collected_edits = collected_edits edit_block "next\n";
        }
        in_edit = 1;
        match_found = 0;
        edit_block = $0 "\n";
        next;
      }
      /^ next/ {
        if (in_edit) {
          edit_block = edit_block $0 "\n";
          if (match_found) {
            collected_edits = collected_edits edit_block;
          }
        }
        in_edit = 0;
        edit_block = "";
        match_found = 0;
        next;
      }
      /^end$/ {
        if (in_edit && match_found) {
          collected_edits = collected_edits edit_block "next\n";
        }
        if (in_config && length(collected_edits) > 0) {
          output = output config_header "\n" collected_edits "end\n\n";
        }
        in_config = 0;
        in_edit = 0;
        config_header = "";
        collected_edits = "";
        match_found = 0;
        next;
      }
      {
        if (in_edit) {
          edit_block = edit_block $0 "\n";
          if ($0 ~ ("(^|[^0-9])" target "($|[^0-9])")) {
            match_found = 1;
          }
        }
      }
      END {
        if (length(output) > 0) {
          printf "%s\n%s", headers, output;
        }
      }
      ' "${source_config}"
    )";

    #### -----------------------------------------------------------------------
    newline;
    if [[ -n "${extracted_configuration}" ]]; then
            echo -n "${extracted_configuration}" > "${output_config}";
            if [[ "${verbose}" == true ]]; then
              cat -n "${output_config}";
              newline 2;
            fi;
      else  message "Warning: No matching blocks found. Output file not written.";
            newline;
            return 1;
    fi;

    return 0;
}; alias parse-cisco='main';

[[ -z "${script_name+x}" ]] && export script_name="${0}";

#------------------------------------------------------------------------------#

if [[ ${#@} -ge 1 && "${1,,}" =~ ^-*(h|help)$ ]]; then
        main --help ;
  else  main "${@}";
        result=${?}; exit ${result};
        ## newline; message "Done."; newline;
fi;

#------------------------------------------------------------------------------#
