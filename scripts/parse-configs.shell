#!/usr/bin/env bash

# File: scripts/parse-configs.shell
# Purpose: Parse a single IP and output to reports/<ip>.json

# Wwarning: Requires Bash version 4.0 or higher

set -euo pipefail;
# set -x;

## POSIX locale standard
export LC_ALL=C;

## Temp-dir and automatic clean-up on exit
TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

#------------------------------------------------------------------------------#

source ./scripts/devops-tools.shell;

#------------------------------------------------------------------------------#

function generate_objects () {
    local ip_address="${1}";
    local outfile="${2}";
    local -a configs=();
    ## Iterate over the ordered list of matched configuration files
    for cfg_file in "${matched_configs_order[@]}"; do
      local blocks="${matched_blocks_byfile[${cfg_file}]}";
      local -a objects=();
      ## Deserialize and clean each matched block
      while IFS= read -r block; do
        local restored="$( sed "s/${divisor}/\n/g" <<< "${block}" | sed '/^[[:space:]]*$/d' )";
        ## Parse lines from the restored block
        local -a lines=();
        while IFS= read -r line || [[ -n "${line}" ]]; do
          lines+=( "${line}" );
        done <<< "${restored}";
        ## Normalize the first line as the object type
        local object_val="$( sed -E 's/^[[:space:]]*//;s/[[:space:]]*$//' <<< "${lines[0]:-}" )";
        ## Identify the specific line where the IP appears
        local entry_val=null;
        for entry in "${lines[@]}"; do
          if grep -Eq "\b${ip_address//./\\.}\b" <<< "${entry}"; then
            entry_val="$( sed -E 's/^[[:space:]]*//;s/[[:space:]]*$//' <<< "${entry}" )";
            break;
          fi;
        done;
        ## Extract optional description
        local desc_val=null;
        for entry in "${lines[@]}"; do
          if [[ "${entry,,}" =~ ^[[:space:]]*description ]]; then
            desc_val="$(
              sed -E 's/^[^"]*"?description"?[[:space:]]*//I' <<< "${entry}" | \
              sed -E 's/^[[:space:]]*//;s/[[:space:]]*$//'
            )";
            break;
          fi;
        done;

        # #-----------------------------------------------------------------------#
        # ## Resolve group by extracting final token from object name
        # local group_val="";
        #
        # # Extract last word from object (e.g., "BU1-NETWORK")
        # local object_key="$( awk '{print $NF}' <<< "${object_val}" | sed -E 's/[[:punct:]]*$//' )";
        #
        # # Search for matching group in matrix where any match contains the object_key
        # group_val="$(
        #   jq -r --arg key "${object_key}" '
        #     map(select(.match[]? | contains($key))) | .[0].group
        #   ' <<< "${matrix_configs}"
        # )";
        #
        # # Fallback to description match (optional, based on your rules â€” keep if needed)
        # if [[ -z "${group_val}" || "${group_val}" == null ]]; then
        #   group_val="$(
        #     jq -r --arg desc "${desc_val}" '
        #       map(select(.match[]? == $desc)) | .[0].group
        #     ' <<< "${matrix_configs}"
        #   )";
        # fi;
        #
        # # Final fallback to config file path
        # if [[ -z "${group_val}" || "${group_val}" == null ]]; then
        #   group_val="$(
        #     sed -E "s|^${configs_dirpath}/||" <<< "${cfg_file}"
        #   )";
        # fi;
        # #-----------------------------------------------------------------------#

        #-----------------------------------------------------------------------#
        ## Resolve group by extracting final token from object name
        local group_val="";

        if [[ "${classify_targets:-false}" == true ]]; then
          local object_key="$( awk '{print $NF}' <<< "${object_val}" | sed -E 's/[[:punct:]]*$//' )";
          group_val="$(
            jq -r --arg key "${object_key}" '
              map(select(.match[]? | contains($key))) | .[0].group
            ' <<< "${matrix_configs}"
          )";
          if [[ -z "${group_val}" || "${group_val}" == null ]]; then
            group_val="$(
              jq -r --arg desc "${desc_val}" '
                map(select(.match[]? == $desc)) | .[0].group
              ' <<< "${matrix_configs}"
            )";
          fi;
        else
          group_val="Unclassified";
        fi;

        if [[ -z "${group_val}" || "${group_val}" == null ]]; then
          group_val="$( sed -E "s|^${configs_dirpath}/||" <<< "${cfg_file}" )";
        fi;
        #-----------------------------------------------------------------------#

        ## Skip if no match was found in this block
        if [[ "${entry_val}" == null || -z "${entry_val}" ]]; then
          continue;
        fi;
        ## For single-line blocks, suppress 'entry' field (set to false)
        local entry_final="\"${entry_val}\"";
        if (( ${#lines[@]} == 1 )); then
          entry_final="false";
        fi;
        ## Construct the object JSON and add to list
        objects+=("$(
          jq -n \
            --arg object "${object_val}" \
            --argjson entry "${entry_final}" \
            --arg desc "${desc_val}" \
            --arg group "${group_val}" \
            '{
              object: $object,
              entry: $entry,
              description: ($desc | select(. != "" and . != "null") // false),
              group: $group
            }'
        )");
      done <<< "${blocks}";
      ## Consolidate objects for the config block
      local objs_json="[]";
      if (( ${#objects[@]} > 0 )); then
        objs_json="$( jq -s . <<< "${objects[*]}" )";
      fi;
      ## Populate Configuration Objects
      configs+=("$(
        jq -n \
          --arg cfg "${cfg_file}" \
          --argjson objs "${objs_json}" \
          '{ config: $cfg, objects: $objs }'
      )");
    done;
    ## Final wrap for the target IP
    local cfgs_json="[]";
    if (( ${#configs[@]} > 0 )); then
      cfgs_json="$( jq -s . <<< "${configs[*]}" )";
    fi;
    ## Generating JSON Configuration
    jq -n \
      --arg ip "${ip_address}" \
      --argjson cfgs "${cfgs_json}" \
      '{ target: $ip, configs: $cfgs }' > "${outfile}";
    return 0;
}; alias generate-objects='generate_objects';

#------------------------------------------------------------------------------#

function main () {
    ## tracking_process ${FUNCNAME} "${@}";
    declare -a file_extensions=();
    oIFS="${IFS}";
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";
      [[ $key =~ ^(configs|c)$ ]] && local configs_dirpath="${value}";
      [[ $key =~ ^(file-ext|x)$ ]] && file_extensions+=(
        $( print "${value}" | tr ':,;\n ' '\n' )
      );
      [[ $key =~ ^(classify|g)$ ]] && local classify_targets=true;
      [[ $key =~ ^(index|n)$ ]] && local target_index="${value}";
      [[ $key =~ ^(ip-addr|i)$ ]] && local target_address="${value}";
      [[ $key =~ ^(validate|v)$ ]] && local validate_address=true;
      [[ $key =~ ^(matrix|m)$ ]] && local matrix_filename="${value}";
      [[ $key =~ ^(reports|r)$ ]] && local reports_folder="${value}";
      #### ---------------------------------------------------------------------
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && export debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && export verbose=true;
    done; IFS="${oIFS}";
    #### -----------------------------------------------------------------------
    [[ -z ${debug:-} ]] && export debug=false;
    [[ -z ${verbose:-} ]] && export verbose=false;

    #### -----------------------------------------------------------------------
    if [[ ${script_helper:-} == true ]]; then
      display_help "${script_name}"  "configs";
      exit 0;
    fi;

    #### -----------------------------------------------------------------------
    ## Target Configurations (file-extensions):
    if [[ -z ${file_extensions+x} || ${#file_extensions[@]} -eq 0 ]]; then
      declare -a file_extensions=( cfg conf cnf );
    fi;

    #### -----------------------------------------------------------------------
    ## Enabling IP/CIDR Blocks Group Classification
    [[ -z ${classify_targets:-} ]] && export classify_targets=false;

    #### -----------------------------------------------------------------------
    ## Processing Custom/Default the Target Configurations (source):
    local configs_dirpath="${configs_dirpath:-configs}";
    if [[ ! -d "${configs_dirpath}" ]]; then
            [[ "${verbose}" == true ]] && \
               error_message "Project Source Configurations path not found: ${configs_dirpath}";
            return 1;
      else  ## Build config file list once, globally scoped
            declare -ga source_configs=();
            local -a find_cmd=( find "$configs_dirpath" -type f \( );
            for ext in "${file_extensions[@]}"; do
              find_cmd+=( -iname "*.${ext}" -o );
            done;
            unset 'find_cmd[-1]';  # Remove trailing -o
            find_cmd+=( \) );
            mapfile -t source_configs < <( "${find_cmd[@]}" | sort );
            if [[ "${debug}" == true ]]; then
              newline; print "Source Configuration files:"; newline;
              for cfg in "${source_configs[@]}"; do
                print "  - ${cfg}"; newline;
              done;
            fi;
    fi;

    #### -----------------------------------------------------------------------
    ## Presetting Target-Index Marker
    [[ -z ${target_index:-} ]] && target_index='';

    #### -----------------------------------------------------------------------
    ## Validating IP Addresses (Skipping?)
    [[ -z ${validate_address:-} ]] && export validate_address=false;
    ## Target IP Address (required):
    if [[ -z "${target_address:-}" ]]; then
            [[ "${debug}" == true ]] && \
               error_message "No IP address provided.";
            return 2;
      else  target_address="$(
              print "${target_address}" | sed -E 's/[[:space:]]+//g' | tr -d '\r'
            )";
            ## Validating Target-Address (IP/CIDR):
            if [[ ${validate_address} == true ]]; then
              validate_address;
            fi;
    fi;

    #### -----------------------------------------------------------------------
    ## Processing Custom/Default the Translation-Matrix (source):
    local matrix_filename="${matrix_filename:-matrix.json}";
    if [[ ! -f "${matrix_filename}" ]]; then
            [[ "${verbose}" == true ]] && \
               error_message "Project Source Matrix-Configs file not found: ${matrix_filename}";
            return 7;
      elif  ! jq -e 'length > 0' "${matrix_filename}" &>/dev/null; then
            [[ "${verbose}" == true ]] && \
               error_message "Matrix file is missing, invalid, or empty: ${matrix_filename}";
            return 8;
      else  local matrix_configs="$( cat "${matrix_filename}" )";
    fi;

    #### -----------------------------------------------------------------------
    ## Custom/Default reports folder:
    local reports_folder="${reports_folder:-reports}";
    mkdir -p "${reports_folder}";

    #### -----------------------------------------------------------------------
    ## Search/Extract (listing) all matching configurations:
    declare -gA matched_configs=();
    declare -ga matched_configs_order=();  # Preserves config file order
    declare -gA matched_blocks_byfile=();
    local search_ip="${target_address%%/*}";
    local divisor="$(
      date +%s%N | base64 | tr -dc 'a-zA-Z0-9'
    )";

    for cfg_file in "${source_configs[@]}"; do
      if grep -qF "${search_ip}" "${cfg_file}"; then
        matched_configs["${cfg_file}"]=true;
        matched_configs_order+=( "${cfg_file}" );
        local content="$(sed 's/!/\n/g' "${cfg_file}")";
        local serialized="";
        while IFS= read -r line || [[ -n "$line" ]]; do
          serialized+="${line}${divisor}";
        done <<< "${content}";
        serialized="$(
          sed -E "s/${divisor}([^ ])/\\n\1/g; s/${divisor}$//" <<< "${serialized}"
        )";
        while IFS= read -r object; do
          if grep -qF "${search_ip}" <<< "${object}"; then
            matched_blocks_byfile["${cfg_file}"]+="${object}"$'\n';
          fi;
        done <<< "${serialized}";
      fi;
    done;

    #### -----------------------------------------------------------------------
    ## Skip output generation if no matching configs found
    if [[ ${#matched_configs_order[@]} -eq 0 ]]; then
      # [[ "${debug}" == true ]] && \
      #    newline; print "No configuration files matched IP: ${target_address}"; newline 2;
      return 0;
    fi;
    # [[ "${verbose}" == true ]] && \
       newline; print "${target_index:-} Valid IP Address: ${target_address}"; newline 2;

    #### -----------------------------------------------------------------------
    ## Generate enriched JSON from matched_blocks_byfile[]
    local tmp_json="${TMP_DIR}/partial.json";
    generate_objects "${target_address}" "${tmp_json}";

    #### -----------------------------------------------------------------------
    ## Listing matching resources (optional) + write to reports
    mkdir -p ${reports_folder}/{lists,json};
    local list_outfile="${reports_folder}/lists/${search_ip}.list";
    local json_outfile="${reports_folder}/json/${search_ip}.json";
    # : > "${list_outfile}";  # truly empty file
    print > "${list_outfile}";  # prepend newline at the top
    for cfg_file in "${matched_configs_order[@]}"; do
      local first_block=true;
      while IFS= read -r matched_object; do
        restored="$(
          sed "s/${divisor}/\n/g" <<< "${matched_object}" | sed '/^[[:space:]]*$/d'
        )";
        if [[ -n "${restored//[[:space:]]/}" ]]; then
          if [[ "${first_block}" == true && -n "${matched_blocks_byfile[$cfg_file]//[[:space:]]/}" ]]; then
            print "\nConfig: ${cfg_file}\n" >> "${list_outfile}";
            [[ "${verbose}" == true ]] && \
               print "Config: ${cfg_file}"; newline 2;
            first_block=false;
          fi;
          print "\n${restored}\n" >> "${list_outfile}";
          [[ "${verbose}" == true ]] && \
             print "${restored}"; newline 2;
        fi;
      done <<< "${matched_blocks_byfile[$cfg_file]}";
    done;

    #### -----------------------------------------------------------------------
    ## Final output JSON object:
    cp "${tmp_json}" "${json_outfile}";
    [[ "${verbose}" == true ]] && \
       jq . "${json_outfile}"; newline;

    return 0;
}; alias parse-configs='main';

#------------------------------------------------------------------------------#

local_state_dir=".local";
mkdir -p "${local_state_dir}";

declare -gA matched_blocks_byfile=();
export script_name="${0}";

if [[ ${#@} -ge 1 && "${1,,}" =~ ^-*(h|help)$ ]]; then
        main --help ;
  else  main "${@}";
        # newline; print "Done."; newline 2;
fi;

unset verbose debug;
