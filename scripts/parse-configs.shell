#!/usr/bin/env bash

## File: scripts/parse-configs.shell

## Purpose: Parse a single IP and output matched configurations to reports/<ip>.json
## Requirements: Bash v4+ and GNU utilities (jq, find, grep, sed, etc.)

## ./scripts/parse-configs.shell --configs="configs" \
##                               --ip-addr="10.0.0.1" \
##                               --index="1" \
##                               --matrix="matrix.json" \
##                               --reports="reports" \
##                               --file-ext="cfg,conf" ;

set -euo pipefail  # Strict mode: exit on error, undefined var use, and pipeline failure
# set -x;          # Enable for execution tracing/debugging

## POSIX locale standard
export LC_ALL=C   # Ensure consistent sorting and character handling (POSIX-compliant)

# Create a secure, temporary working directory (auto-cleaned at script exit)
export TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

#------------------------------------------------------------------------------#

# Load common utility functions (logging, platform detection, etc.)
source ./scripts/tools-devops.shell;
source ./scripts/tools-configs.shell;

#------------------------------------------------------------------------------#
# Function: main
# Entry point of this script

function main () {
    ## tracking_process ${FUNCNAME} "${@}";
    declare -a file_extensions=();
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(classify|g)$ ]] && export classify_targets=true;
      [[ $key =~ ^(file-ext|x)$ ]] && file_extensions+=(
        $( print "${value}" | tr ':,;\n ' '\n' )
      );
      [[ $key =~ ^(configs|c)$ ]] && export configs_dirpath="${value}";
      [[ $key =~ ^(index|n)$ ]] && local target_index="${value}";
      [[ $key =~ ^(ip-addr|i)$ ]] && local target_address="${value}";
      [[ $key =~ ^(logs|o)$ ]] && export enable_logging=true;
      [[ $key =~ ^(matrix|m)$ ]] && local matrix_filename="${value}";
      [[ $key =~ ^(reports|r)$ ]] && local reports_folder="${value}";
      [[ $key =~ ^(validate|v)$ ]] && local validate_address=true;

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "help" ]] && local script_helper=true;
      [[ $key == "debug" ]] && export debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && export verbose=true;
    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied
    [[ -z ${debug:-} ]] && export debug=false;
    [[ -z ${verbose:-} ]] && export verbose=false;

    #### -----------------------------------------------------------------------
    ## Display usage help if requested
    if [[ ${script_helper:-} == true ]]; then
      display_help "${script_name}" "configs";
      exit 0;
    fi;

    #### -----------------------------------------------------------------------
    ## Enabling IP/CIDR Blocks Group Classification
    [[ -z ${classify_targets:-} ]] && export classify_targets=false;

    #### -----------------------------------------------------------------------
    ## Target Configurations (file-extensions):
    ## Set default file extensions if none provided
    if [[ -z ${file_extensions+x} || ${#file_extensions[@]} -eq 0 ]]; then
      declare -a file_extensions=( cfg conf cnf );
    fi;

    #### -----------------------------------------------------------------------
    ## Processing Target Configurations (from JSON input only)
    export configs_dirpath="${configs_dirpath:-configs}";
    declare -ga source_configs=();
    target_configlist_json="targets/${target_address%%/*}.json";
    if [[ ! -f "${target_configlist_json}" ]]; then
      [[ "${verbose}" == true ]] && \
         error_message "Required config list not found: ${target_configlist_json}";
      return 3;
    fi;

    # mapfile -t source_configs < <(
    #   jq -r '.configs[].config' "${target_configlist_json}"
    # );
    mapfile -t source_configs < <(
      jq -r '.configs[] | "\(.config.site)/\(.config.device)"' "${target_configlist_json}"
    );

    # Patch: Prepend configs_dirpath if not already absolute
    for i in "${!source_configs[@]}"; do
      [[ "${source_configs[$i]}" != "${configs_dirpath}/"* ]] && \
      source_configs[$i]="${configs_dirpath}/${source_configs[$i]}";
    done;
    # [[ "${verbose}" == true ]] && \
    #    print "Using precomputed config list: ${target_configlist_json}";
    if [[ "${verbose}" == true ]]; then
      print "Config JSON file used: ${target_configlist_json}";
      print "Extracted config paths from JSON:";
      for cfg in "${source_configs[@]}"; do
        print " - ${cfg}";
      done;
      newline;
    fi;

    #### -----------------------------------------------------------------------
    ## Processing Custom/Default the Translation-Matrix (source):
    ## Load and validate translation matrix (used for grouping logic)
    local matrix_filename="${matrix_filename:-matrix.json}";
    if [[ ! -f "${matrix_filename}" ]]; then
            [[ "${verbose}" == true ]] && \
               error_message "Project Source Matrix-Configs file not found: ${matrix_filename}";
            return 7;
      elif  ! jq -e 'length > 0' "${matrix_filename}" &>/dev/null; then
            [[ "${verbose}" == true ]] && \
               error_message "Matrix file is missing, invalid, or empty: ${matrix_filename}";
            return 8;
      else  export matrix_configs="$( cat "${matrix_filename}" )";
    fi;

    #### -----------------------------------------------------------------------
    ## Custom/Default reports folder:
    export reports_folder="${reports_folder:-reports}";
    mkdir -p ${reports_folder}/{lists,json};

    #### -----------------------------------------------------------------------
    ## Presetting Target-Index Marker
    [[ -z ${target_index:-} ]] && target_index='';

    #### -----------------------------------------------------------------------
    ## Validating IP Addresses (Skipping?)
    [[ -z ${validate_address:-} ]] && export validate_address=false;
    ## Target IP Address (required):
    if [[ -z "${target_address:-}" ]]; then
            [[ "${debug}" == true ]] && \
               error_message "No IP address provided.";
            return 2;
      else  target_address="$(
              print "${target_address}" | sed -E 's/[[:space:]]+//g' | tr -d '\r'
            )";
            ## Validating Target-Address (IP/CIDR):
            if [[ ${validate_address} == true ]]; then
              validate_address;
            fi;
    fi;

    #### -----------------------------------------------------------------------
    ## Holds the list of configuration file paths that matched this specific IP.
    ## This array preserves the original file order and is used to drive structured
    ## JSON generation so that the output reflects the same scan sequence.
    ## Each entry maps to a key in matched_blocks_byfile[] containing the config blocks.
    declare -ga matched_configs_order=();
    # declare -gA matched_blocks_byfile=();
    local search_ip="${target_address%%/*}";

    #### -----------------------------------------------------------------------
    ## Each 100-line chunk that contains the IP is saved to disk using the following pattern:
    ##   <IP-with-dots-replaced>__<config-filename>__<chunk-offset>.chunks
    ## For example:
    ##   10_0_0_1__fw1.conf__200.chunks
    ## This naming allows easy identification of which IP, file, and chunk offset is involved,
    ## and is later used to reassemble blocks back into memory for final processing.

    for cfg_file in "${source_configs[@]}"; do
      mapfile -t lines < <( sed 's/!/\n/g' "$cfg_file" | sed '/^[[:space:]]*$/d' );
      total="${#lines[@]}"; start=0; size=100;
      while (( start < total )); do
        chunk=( "${lines[@]:start:size}" );
        (( ${#chunk[@]} == 0 )) && break;
        block="$( printf "%s\n" "${chunk[@]}" )";
        if grep -qF "${target_address}" <<< "$block"; then
          out="${TMP_DIR}/${target_address//./_}__$(basename "$cfg_file" | tr '/' '_')__$start.chunks";
          print "$block" > "$out";
        fi;
        (( start += size ));
      done;
    done;

    # for cfg_file in "${source_configs[@]}"; do
    #   declare -a serialized_chunks=();
    #   serialize_datablocks "${target_address}" "${cfg_file}" "${divisor}" serialized_chunks;
    #   for idx in "${!serialized_chunks[@]}"; do
    #     out="${TMP_DIR}/${target_address//./_}__$(
    #       basename "$cfg_file" | tr '/' '_'
    #     )__${idx}.chunks";
    #     print "${serialized_chunks[$idx]}" > "${out}";
    #   done;
    # done;

    #### -----------------------------------------------------------------------
    ## Print matched chunk filenames (for visibility/debugging)
    print; print "Matched chunks:"; newline;
    find "${TMP_DIR}" -type f -name "${search_ip//./_}__*.chunks" | sort | while read -r chunk; do
      print " - $(basename "$chunk")"
    done;
    newline;

    ## Rebuild matched blocks into memory structure (by config file)
    for chunk_file in "${TMP_DIR}/${search_ip//./_}"__*.chunks; do
      [[ -f "$chunk_file" ]] || continue;
      cfg_base="$( basename "${chunk_file}" | sed -E "s/^${search_ip//./_}__//;s/__[0-9]+\.chunks$//" )";
      for full_cfg in "${source_configs[@]}"; do
        if [[ "$(basename "$full_cfg")" == "$cfg_base" ]]; then

          matched_blocks_byfile["${full_cfg}"]+=$'\n'"$( < "${chunk_file}" )"$'\n';

          # restored_block="$(
          #   sed "s/${divisor}/\\n/g" < "${chunk_file}"
          # )";
          # matched_blocks_byfile["${full_cfg}"]+=$'\n'"${restored_block}"$'\n';

          matched_configs_order+=( "${full_cfg}" );
          break;
        fi;
      done;
    done;

    #### -----------------------------------------------------------------------
    ## If no matches found, skip output and exit
    if [[ ${#matched_configs_order[@]} -eq 0 ]]; then
      # [[ "${debug}" == true ]] && \
      #    newline; print "No configuration files matched IP: ${target_address}"; newline 2;
      return 0;
    fi;
    # [[ "${verbose}" == true ]] && \
       newline;
       print "${target_index:-} Valid IP Address: ${target_address}";
       newline 2;

    #### -----------------------------------------------------------------------
    ## Generate enriched output JSON from matched_blocks_byfile[]
    local tmp_json="${TMP_DIR}/partial.json";
    generate_objects "${target_address}" "${tmp_json}";

    #### -----------------------------------------------------------------------
    ## Listing matching resources (optional) + write to reports
    ## Optional list output (raw config snippet display)
    local list_outfile="${reports_folder}/lists/${search_ip}.list";
    local json_outfile="${reports_folder}/json/${search_ip}.json";
    # : > "${list_outfile}";  # truly empty file
    print > "${list_outfile}";  # prepend newline at the top

    for cfg_file in "${matched_configs_order[@]}"; do
      [[ -v matched_blocks_byfile["$cfg_file"] ]] || continue;
      local first_block=true;
      config_heading="Config: $(
        relative_configpath "${cfg_file}"
      )";
      print "${nl}${config_heading}${nl}${nl}" >> "${list_outfile}";
      [[ "${verbose}" == true ]] && \
         # print "Config: ${cfg_file}"; newline 2;
         print "${config_heading}"; newline 2;
      while IFS= read -r matched_object; do
        restored="$(
          sed '/^[[:space:]]*$/d' <<< "${matched_object}"
        )";
        if [[ -n "${restored//[[:space:]]/}" ]]; then
          print "${restored}" >> "${list_outfile}";
          [[ "${verbose}" == true ]] && print "${restored}"; newline;
          newline >> "${list_outfile}";
        fi;
      done <<< "${matched_blocks_byfile[$cfg_file]}";
    done;

    cp "${tmp_json}" "${json_outfile}";
    [[ "${verbose}" == true ]] && jq . "${json_outfile}" && echo;

    #### -----------------------------------------------------------------------
    ## Final output JSON object:
    ## Append structured CSV entry for IP to master report
    local csv_outfile="${reports_folder}/reports.csv";
    if [[ ! -f "${csv_outfile}" ]]; then
      print "IP,Config,Object,Entry,Description,Group" > "${csv_outfile}";
    fi;

    jq -r --arg ip "${target_address}" '
      .configs[] as $cfg |
      $cfg.objects[]? |
      [
        $ip,
        $cfg.config,
        .object,
        (if .entry == false then "" else .entry end),
        (if .description == false then "" else .description end),
        .group
      ] | @csv
    ' "${json_outfile}" >> "${csv_outfile}";

    return 0;
}; alias parse-configs='main';

#------------------------------------------------------------------------------#

declare -gA matched_blocks_byfile=();
export script_name="${0}";

if [[ ${#@} -ge 1 && "${1,,}" =~ ^-*(h|help)$ ]]; then
        main --help ;
  else  main "${@}";
        # newline; print "Done."; newline 2;
fi;

unset verbose debug;

#------------------------------------------------------------------------------#
