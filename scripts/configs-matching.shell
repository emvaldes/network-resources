#!/usr/bin/env bash

## File: scripts/configs-matching.shell

## Prevent re-sourcing and ensure one-time initialization
if [[ -n "${__CONFIGS_MATCHING_SOURCED:-}" ]]; then return 0; fi;
readonly __CONFIGS_MATCHING_SOURCED=1;

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: matching-configs ()
##
## Purpose:
##   Filters target IPs to only those that match configuration files,
##   then launches parallel `generate_configslist` jobs to process them.
##
## Input:
##   $1 = optional path to the config list file (defaults to ${configs_list_cache})
##
## Behavior:
##   - Uses `grep -F -f` to locate all lines in all config files that match any target IP.
##   - Builds an in-memory mapping of IP → matched config files.
##   - Overwrites `target_listing[]` to only include matched IPs.
##   - Deduplicates and rewrites `source_configs_list` to include only matched files.
##   - Spawns background jobs (one per matched IP) to generate per-IP JSON summaries.
##
## Output:
##   - Creates `targets/<ip>/<ip>--<site>--<batch_id>.json` for each matched IP.
##   - Logs PID-to-IP mappings and configuration associations for traceability.
##
## Notes:
##   - Maintains two critical maps:
##       targets_jobs2ips_mapping[pid] → ip
##       ip2files[ip] → colon-delimited config file paths
##   - Ensures background jobs are tracked and completed before exiting.
## -------------------------------------------------------------------------- ##

function matching_configs () {

  declare -ga targets_jobs_pid=();          ## Array to hold background job PIDs
  declare -gA targets_jobs2ips_mapping=();  ## Map PID to IP address

  local generate_configslist__logfile="${TMP_DIR}/generate_configslist.logs";
  : > "${generate_configslist__logfile}";

  ## Iterate over IPs in target_listing
  for ip_addr in "${target_listing[@]}"; do

    local report_path="./reports/${ip_addr}";
    local tmp_config_list="${TMP_DIR}/generate-targets--${ip_addr}.list";

    : > "${tmp_config_list}";

    if [[ -d "${report_path}" ]]; then
      for ext in "${file_extensions[@]}"; do
        find "${report_path}" -type f -name "*.${ext}" >> "${tmp_config_list}";
      done;
    fi;

    ## If no configs were found, skip this IP
    [[ ! -s "${tmp_config_list}" ]] && continue;

    local target_file="${targets_location}/${ip_addr}.json";

    (
      generate_targets  "${ip_addr}" \
                        "${target_file}" \
                        "${tmp_config_list}" \
                        "${generate_configslist__logfile}" \
      ;

      #### -----------------------------------------------------------------------
      if [[ "${verbose}" == true ]]; then
        {
          message "Target config's list (IP): ${target_file}";
          jq -r . "${target_file}";
          newline;
        } >> "${actions_logfile:-/dev/null}";
      fi;

    ) &

    local job_pid=$!;
    targets_jobs_pid+=( "${job_pid}" );
    targets_jobs2ips_mapping["${job_pid}"]="${ip_addr}";

  done;

  ## Wait for all jobs to finish
  while (( ${#targets_jobs_pid[@]} > 0 )); do
    local valid_targets_jobs_pid=();
    for pid in "${targets_jobs_pid[@]}"; do
      if ! kill -0 "${pid}" 2>/dev/null; then
        ## Completed
        :
      else
        valid_targets_jobs_pid+=( "${pid}" );
      fi;
    done;
    targets_jobs_pid=( "${valid_targets_jobs_pid[@]}" );
    sleep "${delaying_factor}";
  done;

  if [[ "${verbose}" == true ]]; then
    {
      message "Completed background jobs for matched IPs (${#targets_jobs2ips_mapping[@]}):";
      message "-------------------------------------";
      message " Index  | PID    | IP Address       |";
      message "-------------------------------------";
      for pid in "${!targets_jobs2ips_mapping[@]}"; do
        ip="${targets_jobs2ips_mapping[${pid}]}";
        printf "%-6s | %-15s\n" "${pid}" "${ip}";
      done | cat -n;
      newline;
      print_file "${generate_configslist__logfile}";
    } >> "${actions_logfile:-/dev/null}";
  fi;

  return 0;
}; alias matching-configs='matching_configs';

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: generate_targets ()
##
## Purpose:
##   Builds a detailed, structured JSON object per IP address by reading
##   pre-extracted configuration files from the reports directory.
##
##   For each matching config, it extracts the embedded metadata header,
##   calculates the line count, and constructs a JSON entry that includes:
##     - the source filename
##     - the line count
##     - the path to the serialized .list object file
##     - the full specs header (vendor, model, version, domain, hostname)
##
##   All devices are grouped by site (e.g. "cisco", "fortinet", "misc"),
##   and the final JSON is written as:
##
##     {
##       "target": "<ip>",
##       "locations": {
##         "site": {
##           "devices": [ ... ]
##         }
##       }
##     }
##
## Inputs:
##   $1 = target IP address (e.g. 10.0.0.1)
##   $2 = output JSON file (e.g. ./reports/10.0.0.1/10.0.0.1.json)
##   $3 = optional: list of extracted config files (default: ${configs_list_cache})
##   $4 = optional: log file to write malformed header errors (default: TMP_DIR)
##
## Output:
##   Writes structured JSON to $2 with grouped device entries per site.
##   Logs parsing errors (if any) to $4.
## -------------------------------------------------------------------------- ##

function generate_targets () {

    local ip_addr="${1}";
    local target_file="${2}";
    local source_configs_list="${3:-${configs_list_cache}}";
    local targets_logfile="${4:-${TMP_DIR:-/tmp}/generate_configslist.logs}";

    [[ ! -s "${source_configs_list}" ]] && return 1;

    declare -A site_device_map=();
    local rel_path site device cfg_lines json_head json_spec;

    while IFS= read -r config_file; do
      [[ ! -f "${config_file}" ]] && continue;

      rel_path="${config_file#./reports/${ip_addr}/}";
      site="${rel_path%%/*}";
      device="${rel_path##*/}";

      cfg_lines="$(wc -l < "${config_file}" | tr -d ' ')";

      json_head="$(
        awk '
          BEGIN { in_json=0; depth=0; }
          {
            if (!in_json && $0 ~ /^[[:space:]]*{/) in_json=1;
            if (in_json) {
              print;
              depth += gsub(/{/, "{");
              depth -= gsub(/}/, "}");
              if (depth == 0) exit;
            }
          }
        ' "${config_file}"
      )";

      if ! echo "${json_head}" | jq -e . >/dev/null 2>&1; then
        warning "Malformed JSON header in: ${config_file}" >> "${targets_logfile}";
        continue;
      fi;

      json_spec="$(
        jq -n \
          --arg file "${device}" \
          --argjson lines "${cfg_lines}" \
          --arg path ".objects/${device%.cfg}.list" \
          --argjson specs "${json_head}" \
          '{
            specs: $specs,
            config: {
              file: $file,
              lines: $lines,
              object: $path
            }
          }'
      )";

      site_device_map["${site}"]+="${json_spec}"$'\n';
    done < "${source_configs_list}";

    {

      printf ' { "target": "%s", "locations": { ' "${ip_addr}";
      first=true;

      for site in $(
        printf '%s\n' "${!site_device_map[@]}" | sort -u
      ); do

        [[ -z "${site_device_map[${site}]:-}" ]] && continue;
        ${first} && first=false || printf ',';

        printf ' "%s": { "devices": ' "${site}";
        print  "${site_device_map[${site}]}" | jq -s '.';
        printf ' } ';

      done;
      printf ' } } ';

    } | jq . > "${target_file}";

    return 0;
}; alias generate-targets='generate_targets';

#------------------------------------------------------------------------------#
