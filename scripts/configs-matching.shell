#!/usr/bin/env bash

## File: scripts/configs-matching.shell

## Prevent re-sourcing and ensure one-time initialization
if [[ -n "${__CONFIGS_MATCHING_SOURCED:-}" ]]; then return 0; fi;
readonly __CONFIGS_MATCHING_SOURCED=1;

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: configs_matching ()
##
## Purpose:
##   Filters target IPs to only those that have matching reduced config files,
##   then launches parallel `configs_targets` jobs to build structured summaries.
##
## Inputs:
##   $1 = optional path to the config list file (defaults to ${configs_list_cache})
##
## Behavior:
##   - Scans per-IP `${reports_folder}/<ip-address>/` folders for presence of reduced config files.
##   - Filters out IPs without any matching config files.
##   - Builds a temporary per-IP list of reduced config files.
##   - Spawns background jobs (one per IP) to call `configs_targets()`,
##     which assembles the JSON summary with metadata and `.list` references.
##
## Outputs:
##   - Writes: `./targets/<ip-adress>.json` for each IP, structured by site/vendor/device.
##   - Logs mappings and execution status for traceability.
##
## Notes:
##   - Tracks background job completion using:
##       targets_jobs2ips_mapping[pid] → ip-adress
##   - Summary logs are written to ${TMP_DIR}/configs-targets.logs
## -------------------------------------------------------------------------- ##

function configs_matching () {

    #### -----------------------------------------------------------------------
    local configs_matching__script="configs-matching";

    declare -ga targets_jobs_pid=();          ## Array to hold background job PIDs
    declare -gA targets_jobs2ips_mapping=();  ## Map PID to IP address

    #### -----------------------------------------------------------------------
    ## Iterate over IPs in target_listing
    for ip_address in "${target_listing[@]}"; do

      local report_path="${reports_folder}/${ip_address}";
      local configs_objects="${TMP_DIR}/configs-targets--${ip_address}.list";
      : > "${configs_objects}";

      if [[ -d "${report_path}" ]]; then
        for ext in "${file_extensions[@]}"; do
          find "${report_path}" -type f -name "*.${ext}" >> "${configs_objects}";
        done;
      fi;

      ## If no configs were found, skip this IP
      [[ ! -s "${configs_objects}" ]] && continue;

      local target_config="${targets_location}/${ip_address}.json";
      local configs_targets__console="${TMP_DIR}/configs-targets--${ip_address}"

      (
        configs_targets --search="${ip_address}" \
                        --source="${configs_objects}" \
                        --target="${target_config}" \
                        --logger="${configs_targets__console}.console" \
                        --verbose \
        >> "${logs_location}/${configs_matching__script}.log" 2>&1 ;

      ) &

      local job_pid=$!;
      targets_jobs_pid+=( "${job_pid}" );
      targets_jobs2ips_mapping["${job_pid}"]="${ip_address}";

    done;

    #### -----------------------------------------------------------------------
    ## Wait for all jobs to finish
    while (( ${#targets_jobs_pid[@]} > 0 )); do
      local valid_targets_jobs_pid=();
      for pid in "${targets_jobs_pid[@]}"; do
        if ! kill -0 "${pid}" 2>/dev/null; then
                ## Job finished — no action here
                logger="${targets_jobs2ips_mapping[$pid]}";
          else  valid_targets_jobs_pid+=( "${pid}" );
        fi;
      done;
      targets_jobs_pid=( "${valid_targets_jobs_pid[@]}" );
      sleep "${delaying_factor}";
    done;

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        message "Completed background jobs for matched IPs (${#targets_jobs2ips_mapping[@]}):";
        message "-------------------------------------";
        message " Index  | PID    | IP Address       |";
        message "-------------------------------------";
        for pid in "${!targets_jobs2ips_mapping[@]}"; do
          ip_address="${targets_jobs2ips_mapping[${pid}]}";
          printf "%-6s | %-15s\n" "${pid}" "${ip_address}";
        done | cat -n;
        newline;
      } >> "${configs_matching__console:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    ## Collecting all background-jobs console outputs
    {
      for pid in "${!targets_jobs2ips_mapping[@]}"; do
        ip_address="${targets_jobs2ips_mapping[${pid}]}";
        target_config="${targets_location}/${ip_address}.json";
        if [[ -s "${target_config}" && -f "${target_config}" ]]; then
          message "Completed Configuration Targets (IP): ${target_config}";
          jq -r . "${target_config}" || warning "Invalid JSON: ${target_config}";
          newline;
        fi;
      done;
    } >> "${configs_matching__console}";

    return 0;
}; alias configs-matching='configs_matching';

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: configs_targets ()
##
## Purpose:
##   Builds a detailed, structured JSON object per IP address by reading
##   pre-extracted configuration files from the reports directory.
##
##   For each matching config, it extracts the embedded metadata header,
##   calculates the line count, and constructs a JSON entry that includes:
##     - the source filename
##     - the line count
##     - the path to the serialized .list object file
##     - the full specs header (vendor, model, version, domain, hostname)
##
##   All devices are grouped by site (e.g. "cisco", "fortinet", "misc"),
##   and the final JSON is written as:
##
##     {
##       "target": "<ip-address>",
##       "locations": {
##         "site": {
##           "devices": [ ... ]
##         }
##       }
##     }
##
## Inputs:
##   $1 = target IP address (e.g. 10.0.0.1)
##   $2 = output JSON file (e.g. ${reports_folder}/10.0.0.1/10.0.0.1.json)
##   $3 = optional: list of extracted config files (default: ${configs_list_cache})
##   $4 = optional: log file to write malformed header errors (default: TMP_DIR)
##
## Output:
##   Writes structured JSON to $2 with grouped device entries per site.
##   Logs parsing errors (if any) to $4.
## -------------------------------------------------------------------------- ##

function configs_targets () {

    ## tracking_process ${FUNCNAME} "${@}";
    oIFS="${IFS}";

    ## Process command-line arguments and map them to local variables
    for xitem in "${@}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";

      #### ---------------------------------------------------------------------
      ## Match accepted arguments
      [[ $key =~ ^(search|p)$ ]] && local search_pattern="${value}";
      [[ $key =~ ^(source|s)$ ]] && local source_config="${value}";
      [[ $key =~ ^(target|t)$ ]] && local target_config="${value}";
      [[ $key =~ ^(logger|l)$ ]] && local target_logfile="${value}";

      #### ---------------------------------------------------------------------
      ## Special options
      [[ $key == "debug" ]] && local debug=true;
      [[ $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true;

    done; IFS="${oIFS}";

    #### -----------------------------------------------------------------------
    ## Set default values if not supplied
    [[ -z ${debug:-} ]] && debug=false;
    [[ -z ${dry_run:-} ]] && dry_run=false;
    [[ -z ${verbose:-} ]] && verbose=false;

    #### -----------------------------------------------------------------------
    [[ -z "${source_config:-}" ]] && local source_config="${configs_list_cache}";

    #### -----------------------------------------------------------------------
    if [[ -z "${target_logfile:-}" ]]; then
      local target_logfile="${console_location}/configs-targets.console";
      touch "${target_logfile}";
    fi;
    # touch "${target_logfile}";  ## Clear the log file if it exists

    [[ ! -s "${source_config}" ]] && return 1;

    declare -A site_device_map=();
    local rel_path site device cfg_lines json_head json_spec;

    while IFS= read -r config_file; do
      [[ ! -f "${config_file}" ]] && continue;

      rel_path="${config_file#./${reports_folder}/${search_pattern}/}";
      site="${rel_path%%/*}";
      device="${rel_path##*/}";

      cfg_lines="$(
        wc -l < "${config_file}" | \
        tr -d ' '
      )";

      #### -----------------------------------------------------------------------
      json_head="$(
        awk '
          BEGIN { in_json=0; depth=0; }
          {
            if (!in_json && $0 ~ /^[[:space:]]*{/) in_json=1;
            if (in_json) {
              print;
              depth += gsub(/{/, "{");
              depth -= gsub(/}/, "}");
              if (depth == 0) exit;
            }
          }
        ' "${config_file}"
      )";

      if ! echo "${json_head}" | jq -e . >/dev/null 2>&1; then
        warning "Malformed JSON header in: ${config_file}" >> "${target_logfile}";
        continue;
      fi;

      #### -----------------------------------------------------------------------
      json_spec="$(
        jq -n \
          --arg file "${device}" \
          --argjson lines "${cfg_lines}" \
          --arg path ".objects/${device%.cfg}.list" \
          --arg specs "${json_head}" \
          '{
            specs: ($specs | fromjson),
            config: {
              file: $file,
              lines: $lines,
              object: $path
            }
          }'
      )";

      site_device_map["${site}"]+="${json_spec}"$'\n';
    done < "${source_config}";

    {

      printf ' { "target": "%s", "locations": { ' "${search_pattern}";
      first=true;

      for site in $(
        printf '%s\n' "${!site_device_map[@]}" | sort -u
      ); do

        [[ -z "${site_device_map[${site}]:-}" ]] && continue;
        ${first} && first=false || printf ',';

        printf ' "%s": { "devices": ' "${site}";
        print  "${site_device_map[${site}]}" | jq -s '.';
        printf ' } ';

      done;
      printf ' } } ';

    } | jq . > "${target_config}";

    # #### -----------------------------------------------------------------------
    # if [[ "${verbose}" == true ]]; then
    #   {
    #     print_file "${target_config}" | jq -r .;
    #     newline;
    #   } >> "${target_logfile:-/dev/null}";
    # fi;

    return 0;
}; alias configs-targets='configs_targets';

#------------------------------------------------------------------------------#
