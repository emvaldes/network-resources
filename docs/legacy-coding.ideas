
# -----------------------------------------------------------------------------#
# Legacy (Traditional) mechanism to mange background jobs.
for ip_addr in "${target_listing[@]}"; do
  ip_cleaned="$(
    print "${ip_addr}" | tr -d '\r'
  )";
  target_file="targets/${ip_cleaned}.list";
  (
    matched_files="$(
      grep -lF "${ip_cleaned}" $( < "${configs_list_cache}" ) 2>/dev/null || true
    )";
    if [[ -n "${matched_files}" ]]; then
      # prefix="${configs_dirpath%/}/";
      # fixed_listing="$( sed "s|${prefix}||g" <<< "${matched_files}" )";
      printf "%s\n" ${matched_files} > "${target_file}";
    fi;
  ) &
done;

# -----------------------------------------------------------------------------#
## Launch parallel parsing jobs for matched IPs
ip_index=0;
total_ips=${#filtered_target_listing[@]};
while (( ip_index < total_ips )); do
  running_jobs=$(
    jobs -rp | wc -l
  );
  available_slots=$(( parallel_threads - running_jobs ));
  if (( available_slots > 0 )); then
    for (( i = 0; i < available_slots && ip_index < total_ips; i++ )); do
      ip_addr="${filtered_target_listing[ip_index++]}";
      padded_index="$( printf "%0${#total_ips}d" "${ip_index}" )";
      print "[START] IP: ${ip_addr}${nl}" >> "${reports_folder}/reports.log"; newline;
      [[ "${debug}" == true ]] && \
         print "[POOL] Launching job (${ip_addr})[$ip_index] ..."; newline;
      (
        execute=(
          ./scripts/parse-configs.shell
          --configs="${configs_dirpath}"
          --ip-addr="${ip_addr}"
          --index="${padded_index}"
          --matrix="${matrix_filename}"
          --reports="${reports_folder}"
          --file-ext="$(
            IFS=,; print "${file_extensions[*]}"
          )"
        );
        [[ "${classify_targets}" == true ]] && execute+=( --classify );
        [[ "${validate_address}" == true ]] && execute+=( --validate );
        [[ "${verbose}" == true ]] && execute+=( --verbose );
        [[ "${debug}" == true ]] && execute+=( --debug );

        (
          if [[ "${enable_logging:-}" == true ]]; then
                  mkdir -p "${local_state_dir}/jobs" "${local_state_dir}/errors";
                  logfile="${local_state_dir}/jobs/${ip_addr}.job";
                  if [[ "${debug}" == true ]]; then
                          bash -x "${execute[@]}" > "${logfile}" 2>&1;
                    else  "${execute[@]}" > "${logfile}" 2>&1;
                  fi;
            else  if [[ "${debug}" == true ]]; then
                          bash -x "${execute[@]}" >/dev/null 2>&1;
                    else  "${execute[@]}" >/dev/null 2>&1;
                  fi;
          fi;
          status=$?;
          if (( status != 0 )); then
                  {
                    print "[ERROR] IP: ${ip_addr} failed :: exit ${status}"; newline;
                    print "  See: ${logfile}";
                  } >> "${local_state_dir}/errors/errors.log";
            else  print "${nl}[DONE] IP: ${ip_addr}" >> "${reports_folder}/reports.log";
          fi;
        ) &
      ) &
    done;
  fi;
  sleep ${delaying_factor};
done;

#------------------------------------------------------------------------------#
## Function: wait_for_completion
## Purpose: Wait for background jobs and flush I/O buffers to ensure data integrity
function waitfor_completion () {
    wait;       ## Wait for all background jobs to finish
    sleep 0.5;  ## Allow I/O buffers to settle
    sync;       ## Flush all in-memory buffers to disk
    return 0;
}; alias waitfor-completion='waitfor_completion';

#------------------------------------------------------------------------------#
## Processing Custom/Default the Target Configurations (source):
export configs_dirpath="${configs_dirpath:-configs}";
declare -ga source_configs=();
ip_list_file="targets/${target_address%%/*}.list";
if [[ -f "${ip_list_file}" ]]; then
        mapfile -t source_configs < "${ip_list_file}";
        [[ "${verbose}" == true ]] && \
           print "Using pre-matched config list: ${ip_list_file}";
  elif  [[ -d "${configs_dirpath}" ]]; then
        local -a find_cmd=( find "$configs_dirpath" -type f \( );
        for ext in "${file_extensions[@]}"; do
          find_cmd+=( -iname "*.${ext}" -o );
        done;
        unset 'find_cmd[-1]';
        find_cmd+=( \) );
        mapfile -t source_configs < <( "${find_cmd[@]}" | sort );
  else  [[ "${verbose}" == true ]] && \
           error_message "Project Source Configurations path not found: ${configs_dirpath}";
        return 1;
fi;

#------------------------------------------------------------------------------#

#### ---------------------------------------------------------------------------
## Each 100-line chunk that contains the IP is saved to disk using the following pattern:
##   <IP-with-dots-replaced>__<config-filename>__<chunk-offset>.chunks
## For example:
##   10_0_0_1__fw1.conf__200.chunks
## This naming allows easy identification of which IP, file, and chunk offset is involved,
## and is later used to reassemble blocks back into memory for final processing.

# for cfg_file in "${source_configs[@]}"; do
#   mapfile -t lines < <( sed 's/!/\n/g' "$cfg_file" | sed '/^[[:space:]]*$/d' );
#   total="${#lines[@]}"; start=0; size=100;
#   while (( start < total )); do
#     chunk=( "${lines[@]:start:size}" );
#     (( ${#chunk[@]} == 0 )) && break;
#     block="$( printf "%s\n" "${chunk[@]}" )";
#     if grep -qF "${target_address}" <<< "$block"; then
#       out="${TMP_DIR}/${target_address//./_}__$(basename "$cfg_file" | tr '/' '_')__$start.chunks";
#       print "$block" > "$out";
#     fi;
#     (( start += size ));
#   done;
# done;
#
# #### -----------------------------------------------------------------------
# ## Print matched chunk filenames (for visibility/debugging)
# print; print "Matched chunks:"; newline;
# find "${TMP_DIR}" -type f -name "${search_ip//./_}__*.chunks" | sort | while read -r chunk; do
#   print " - $(basename "$chunk")"
# done;
# newline;
#
# ## Rebuild matched blocks into memory structure (by config file)
# for chunk_file in "${TMP_DIR}/${search_ip//./_}"__*.chunks; do
#   [[ -f "$chunk_file" ]] || continue;
#   cfg_base="$( basename "${chunk_file}" | sed -E "s/^${search_ip//./_}__//;s/__[0-9]+\.chunks$//" )";
#   for full_cfg in "${source_configs[@]}"; do
#     if [[ "$(basename "$full_cfg")" == "$cfg_base" ]]; then
#
#       matched_blocks_byfile["${full_cfg}"]+=$'\n'"$( < "${chunk_file}" )"$'\n';
#       matched_configs_order+=( "${full_cfg}" );
#       break;
#     fi;
#   done;
# done;
#
# #### -----------------------------------------------------------------------
# ## If no matches found, skip output and exit
# if [[ ${#matched_configs_order[@]} -eq 0 ]]; then
#   # [[ "${debug}" == true ]] && \
#   #    newline; print "No configuration files matched IP: ${target_address}"; newline 2;
#   return 0;
# fi;
# # [[ "${verbose}" == true ]] && \
#    newline;
#    print "${target_index:-} Valid IP Address: ${target_address}";
#    newline 2;
