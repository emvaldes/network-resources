#!/usr/bin/env bash

## File: scripts/configs-matching.shell

## Prevent re-sourcing and ensure one-time initialization
if [[ -n "${__CONFIGS_MATCHING_SOURCED:-}" ]]; then return 0; fi;
readonly __CONFIGS_MATCHING_SOURCED=1;

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: matching-configs ()
##
## Purpose:
##   Filters target IPs to only those that match configuration files,
##   then launches parallel `generate_configslist` jobs to process them.
##
## Input:
##   $1 = optional path to the config list file (defaults to ${configs_list_cache})
##
## Behavior:
##   - Uses `grep -F -f` to locate all lines in all config files that match any target IP.
##   - Builds an in-memory mapping of IP → matched config files.
##   - Overwrites `target_listing[]` to only include matched IPs.
##   - Deduplicates and rewrites `source_configs_list` to include only matched files.
##   - Spawns background jobs (one per matched IP) to generate per-IP JSON summaries.
##
## Output:
##   - Creates `targets/<ip>/<ip>--<site>--<batch_id>.json` for each matched IP.
##   - Logs PID-to-IP mappings and configuration associations for traceability.
##
## Notes:
##   - Maintains two critical maps:
##       targets_jobs2ips_mapping[pid] → ip
##       ip2files[ip] → colon-delimited config file paths
##   - Ensures background jobs are tracked and completed before exiting.
## -------------------------------------------------------------------------- ##

function matching_configs () {

  declare -ga targets_jobs_pid=();          ## Array to hold background job PIDs
  declare -gA targets_jobs2ips_mapping=();  ## Map PID to IP address

  local generate_configslist__logfile="${TMP_DIR}/generate_configslist.logs";
  : > "${generate_configslist__logfile}";

  ## Iterate over IPs in target_listing
  for ip_addr in "${target_listing[@]}"; do

    local report_path="./reports/${ip_addr}";
    local tmp_config_list="${TMP_DIR}/configslist--${ip_addr}.list";

    : > "${tmp_config_list}";

    if [[ -d "${report_path}" ]]; then
      for ext in "${file_extensions[@]}"; do
        find "${report_path}" -type f -name "*.${ext}" >> "${tmp_config_list}";
      done;
    fi;

    ## If no configs were found, skip this IP
    [[ ! -s "${tmp_config_list}" ]] && continue;

    local target_file="${targets_location}/${ip_addr}.json";

    (
      generate_configslist  "${ip_addr}" \
                            "${target_file}" \
                            "${tmp_config_list}" \
                            "${generate_configslist__logfile}";

      #### -----------------------------------------------------------------------
      if [[ "${verbose}" == true ]]; then
        {
          message "Target config's list (IP): ${target_file}";
          jq -r . "${target_file}";
          newline;
        } >> "${actions_logfile:-/dev/null}";
      fi;

    ) &

    local job_pid=$!;
    targets_jobs_pid+=( "${job_pid}" );
    targets_jobs2ips_mapping["${job_pid}"]="${ip_addr}";

  done;

  ## Wait for all jobs to finish
  while (( ${#targets_jobs_pid[@]} > 0 )); do
    local valid_targets_jobs_pid=();
    for pid in "${targets_jobs_pid[@]}"; do
      if ! kill -0 "${pid}" 2>/dev/null; then
        ## Completed
        :
      else
        valid_targets_jobs_pid+=( "${pid}" );
      fi;
    done;
    targets_jobs_pid=( "${valid_targets_jobs_pid[@]}" );
    sleep "${delaying_factor}";
  done;

  if [[ "${verbose}" == true ]]; then
    {
      message "Completed background jobs for matched IPs (${#targets_jobs2ips_mapping[@]}):";
      message "-------------------------------------";
      message " Index  | PID    | IP Address       |";
      message "-------------------------------------";
      for pid in "${!targets_jobs2ips_mapping[@]}"; do
        ip="${targets_jobs2ips_mapping[${pid}]}";
        printf "%-6s | %-15s\n" "${pid}" "${ip}";
      done | cat -n;
      newline;
      print_file "${generate_configslist__logfile}";
    } >> "${actions_logfile:-/dev/null}";
  fi;

  return 0;
}; alias matching-configs='matching_configs';

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: generate_configslist ()
##
## Purpose:
##   Scans a list of configuration files for matches of a specific IP address.
##   For each match, it builds a summarized JSON structure capturing:
##     - the site and device (parsed from the config path)
##     - total line count in the config
##     - number of IP matches
##
## Inputs:
##   $1 = target IP address (e.g. 10.0.0.1)
##   $2 = output JSON path (e.g. ./targets/10.0.0.1.json)
##   $3 = optional: path to list of config files (default: ${configs_list_cache})
##   $4 = optional: tracing file to record intermediate state (used during batching)
##
## Output:
##   Writes a JSON object to $2 in the form: { "configs": [ ... ] }
##   If tracing file ($4) is set, it merges into that file as well.
##   Logs the operation to the actions log.
## -------------------------------------------------------------------------- ##

function generate_configslist () {

  local ip_addr="${1}";
  local target_file="${2}";
  local source_configs_list="${3}";

  local targets_logfile="${4:-${TMP_DIR:-/tmp}/generate_configslist--${ip_addr}.log}";
  declare -A site_json_map=();

  if [[ -s "${source_configs_list}" ]]; then

    while IFS= read -r config_file; do
      [[ -f "${config_file}" ]] || continue;

      local config_lines match_count rel_path site device;

      config_lines=$( wc -l < "${config_file}" );
      local match_count=$(
        grep -oE "(^|[^0-9.])${ip_addr//./\\.}([^0-9.]|$)" "${config_file}" | \
        wc -l | tr -d ' '
      );
      [[ "${match_count}" -eq 0 ]] && continue;

      ## Strip ./reports/<ip>/ prefix → isolate vendor/device path
      rel_path="${config_file#./reports/${ip_addr}/}";

      ## Extract vendor and device filename
      site="${rel_path%%/*}";   ## → cisco / fortinet / misc
      device="${rel_path#*/}";  ## → access-sw1-west.cfg, etc

      site_json_map["$site"]+=$(
        jq -n \
          --arg device "${device}" \
          --argjson lines "${config_lines}" \
          --argjson count "${match_count}" \
          '{ device: $device, lines: $lines, count: $count }'
      )
      site_json_map["$site"]+=$'\n';
    done < "${source_configs_list}";

    {
      echo -n '{';
      local first=true;
      for site in "${!site_json_map[@]}"; do
        [[ "${first}" == true ]] && first=false || echo ',';
        echo -n "  \"${site}\": [";
        jq -s '.' <<< "${site_json_map[$site]}" | sed '1d;$d';
        echo -n ']';
      done;
      echo -n '}';
    } | jq -S -r . > "${target_file}";

  fi;

  return 0;
}; alias generate-configslist='generate_configslist';

#------------------------------------------------------------------------------#
