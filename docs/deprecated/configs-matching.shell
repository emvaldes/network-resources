#!/usr/bin/env bash

## File: scripts/configs-matching.shell

## Prevent re-sourcing and ensure one-time initialization
if [[ -n "${__CONFIGS_MATCHING_SOURCED:-}" ]]; then return 0; fi;
readonly __CONFIGS_MATCHING_SOURCED=1;

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: matching-configs ()
##
## Purpose:
##   Filters target IPs to only those that match configuration files,
##   then launches parallel `generate_configslist` jobs to process them.
##
## Input:
##   $1 = optional path to the config list file (defaults to ${configs_list_cache})
##
## Behavior:
##   - Uses `grep -F -f` to locate all lines in all config files that match any target IP.
##   - Builds an in-memory mapping of IP → matched config files.
##   - Overwrites `target_listing[]` to only include matched IPs.
##   - Deduplicates and rewrites `source_configs_list` to include only matched files.
##   - Spawns background jobs (one per matched IP) to generate per-IP JSON summaries.
##
## Output:
##   - Creates `targets/<ip>/<ip>--<site>--<batch_id>.json` for each matched IP.
##   - Logs PID-to-IP mappings and configuration associations for traceability.
##
## Notes:
##   - Maintains two critical maps:
##       targets_jobs2ips_mapping[pid] → ip
##       ip2files[ip] → colon-delimited config file paths
##   - Ensures background jobs are tracked and completed before exiting.
## -------------------------------------------------------------------------- ##

function matching_configs () {

    local input_parameter="PARAMETER";
    local source_configs_list="${1:-${configs_list_cache}}";

    declare -ga targets_jobs_pid=();          ## Array to hold the PIDs of the background jobs
    declare -gA targets_jobs2ips_mapping=();  ## Associative array to map PIDs to IPs

    if [[ "${verbose}" == true ]]; then
      {
        message "[EXECUTE]   ${FUNCNAME}";
        message "[${input_parameter}] source_configs_list:\n   $(
          printf '%*s' "${#input_parameter}"
        )${source_configs_list}";
        # newline;
        # print_file "${source_configs_list}";
      } >> "${actions_logfile:-/dev/null}";
    fi;

    # Build IP lookup set and output map
    declare -A targets=();
    declare -A ip2files=();

    for ip in "${target_listing[@]}"; do
      targets["$ip"]=1;
      ip2files["$ip"]="";
    done;

    # Read all matching lines at once
    # mapfile -t matched_lines < <(
    #   grep -HF -f "${source_addresses}" $( <"${source_configs_list}" )
    # );
    matched_lines=()
    tmpfile="${TMP_DIR}/matched_lines.$$"
    : > "${tmpfile}"

    while IFS= read -r cfg; do
      grep -HF -f "${source_addresses}" "$cfg"
    done < "${source_configs_list}" >> "${tmpfile}"

    mapfile -t matched_lines < "${tmpfile}"
    rm -f "${tmpfile}"

    # Flat, single-pass assignment
    for line in "${matched_lines[@]}"; do
      file="${line%%:*}";
      entry="${line#*:}";
      # Tokenize IPs in this line (not scanning target list)
      for token in $(grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' <<< "$entry"); do
        [[ ${targets["$token"]+x} ]] || continue;
        current="${ip2files[$token]}";
        [[ ":$current:" == *":$file:"* ]] && continue;
        ip2files["$token"]+="${current:+":"}$file";
      done;
    done;

    # Overwrite target_listing with filtered IPs that had matches
    target_listing=();
    for ip in "${!ip2files[@]}"; do
      [[ -n "${ip2files[$ip]}" ]] && target_listing+=( "$ip" );
    done;

    ## Flatten and deduplicate matched files into the source_configs_list
    {
      for ip in "${!ip2files[@]}"; do
        [[ -n "${ip2files[$ip]}" ]] || continue;
        tr ':' '\n' <<< "${ip2files[$ip]}"
      done | sort -u;
    } > "${source_configs_list}"

    if [[ "${verbose}" == true ]]; then
      {
        newline;
        print_file "${source_configs_list}";
        newline;
      } >> "${actions_logfile:-/dev/null}";
    fi;

    #### -----------------------------------------------------------------------
    local generate_configslist__logfile="${TMP_DIR}/generate_configslist.logs";
    :> "${generate_configslist__logfile}";

    ## Iterate over filtered and cleaned target IP addresses
    for ip_addr in "${target_listing[@]}"; do

      target_file="${targets_location}/${ip_addr}.json";

      site_name="$(
        sed -E "s|^${configs_dirpath}/||" <<< "${ip2files[${ip_addr}]%%:*}" | \
        cut -d/ -f1
      )";

      target_dirpath="${targets_location}/${ip_addr}";
      tracing_record="${target_dirpath}/${ip_addr}--${site_name}--${batch_id}.json";

      mkdir -p "${target_dirpath}";
      touch "${tracing_record}";

      (
        generate_configslist  "${ip_addr}" \
                              "${target_file}" \
                              "${source_configs_list}" \
                              "${tracing_record}" \
                              "${generate_configslist__logfile}" \
        ;
      ) &

      job_pid=$!;
      targets_jobs_pid+=( "${job_pid}" );
      targets_jobs2ips_mapping["${job_pid}"]="${ip_addr}";

    done;

    ## Monitor the background jobs until all are completed
    while (( ${#targets_jobs_pid[@]} > 0 )); do
      valid_targets_jobs_pid=();
      for pid in "${targets_jobs_pid[@]}"; do
        if ! kill -0 "${pid}" 2>/dev/null; then
                ## Job completed
                ip_address="${targets_jobs2ips_mapping[${pid}]}";  ## Retrieve the IP associated with this job PID
                # message "[INFO] Completed (${pid}): ${ip_address}" >> "${actions_logfile:-/dev/null}";
          else  valid_targets_jobs_pid+=( "${pid}" );  ## Job still running
        fi;
      done;
      targets_jobs_pid=( "${valid_targets_jobs_pid[@]}" );
      sleep ${delaying_factor}  ## Short delay to prevent excessive CPU usage
    done;

    #### -----------------------------------------------------------------------
    if [[ "${verbose}" == true ]]; then
      {
        message "Matched IPs to [${site}] configs (${#targets_jobs2ips_mapping[@]}):";
        message "-------------------------------------";
        message "PID    | IP Address      => Config(s)";
        message "-------------------------------------";
        for pid in "${!targets_jobs2ips_mapping[@]}"; do
          ip="${targets_jobs2ips_mapping[${pid}]}";
          config_raw="${ip2files[${ip}]:-none}";
          config_cleaned="$(
            sed "s|${configs_dirpath}/${site}/||g" <<< "${config_raw}" | \
            sed 's/:/ + /g'
          )";
          printf "%-6s | %-15s => %s\n" "${pid}" "${ip}" "${config_cleaned}";
        done;
        newline;
        print_file "${generate_configslist__logfile}";
      } >> "${actions_logfile:-/dev/null}";
    fi;

    return 0;
}; alias matching-configs='matching_configs';

## -------------------------------------------------------------------------- ##
## Function: configs-matching :: generate_configslist ()
##
## Purpose:
##   Scans a list of configuration files for matches of a specific IP address.
##   For each match, it builds a summarized JSON structure capturing:
##     - the site and device (parsed from the config path)
##     - total line count in the config
##     - number of IP matches
##
## Inputs:
##   $1 = target IP address (e.g. 10.0.0.1)
##   $2 = output JSON path (e.g. ./targets/10.0.0.1.json)
##   $3 = optional: path to list of config files (default: ${configs_list_cache})
##   $4 = optional: tracing file to record intermediate state (used during batching)
##
## Output:
##   Writes a JSON object to $2 in the form: { "configs": [ ... ] }
##   If tracing file ($4) is set, it merges into that file as well.
##   Logs the operation to the actions log.
## -------------------------------------------------------------------------- ##

function generate_configslist () {

    local ip_addr="${1}";
    local target_file="${2}";

    local source_configs_list="${3:-${configs_list_cache}}";
    # message "[generate_configslist] Configurations File: ${source_configs_list}";

    ## Recording iteration configuration
    local tracing_record="${4:-}";

    ## Recording the generated_configslist actions
    local target_logfile="${5:-${TMP_DIR:-/tmp}/generate_configslist--${ip_addr}.log}";

    ## Objective: Match configuration files for the current IP address
    ## Warning:   Avoiding additional disk I/O in favor of in-memory mapping (associative array: ip2files)
    # local matched_files=$(
    #   grep -lE "(^|[^0-9.])${ip_addr//./\\.}([^0-9.]|$)" \
    #            $( <"${source_configs_list}" ) 2>/dev/null || true
    # );

    ## If matched files exist, generate the JSON structure
    # if [[ -n "${matched_files}" ]]; then
    # if [[ -n "${ip2files[${ip_addr}]:-}" ]]; then
    if [[ -s "${source_configs_list}" ]]; then

      ## Initialize an empty JSON array
      config_json="[]";

      ## Iterate through matched files and prepare JSON entries
      while IFS= read -r config_file; do
        ## Remove the "configs_dirpath" prefix from each file path

        ## Strip full prefix before storing to JSON
        config_file="${config_file#"${configs_dirpath%/}/"}";

        ## Count the number of lines in the config file

        # config_lines=$(
        #   wc -l < "${configs_dirpath}/${config_file}"
        # );
        config_lines=$( wc -l < "${config_file}" )

        ## Count how many times the IP appears in the config file
        match_count=$(
          grep -oE "(^|[^0-9.])${ip_addr//./\\.}([^0-9.]|$)" \
                   "${configs_dirpath}/${config_file}" | \
          wc -l | tr -d ' '
        );
        ## Extracting target Site and Device items
        site="${config_file%%/*}"
        device="${config_file#*/}"
        ## Generate JSON entry for the current file and append it to the JSON array
        config_json=$(
          print "${config_json}" |
          jq --arg site "${site}" \
             --arg device "${device}" \
             --argjson lines "${config_lines}" \
             --argjson count "${match_count}" \
             '. += [ { "config": { "site": $site, "device": $device }, "lines": $lines, "count": $count } ]'
        );
      # done <<< "${matched_files}";
      # done <<< "$(
      #   tr ':' '\n' <<< "${ip2files[${ip_addr}]}"
      # )";
      done < "${source_configs_list}"

      ## Wrap the array into the final structure with {configs: $configs}
      final_json=$(
        print "${config_json}" | jq '{ configs: . }'
      );
      ## Save the final JSON to the target file
      jq -r <<< "${final_json}" > "${target_file}";

      ## If tracing is enabled, append the JSON to the tracing record
      if [[ -n "${tracing_record}" ]]; then
        if [[ -f "${tracing_record}" ]]; then
                # Merge new configs into existing file
                jq --slurp  '{ configs: map(.configs) | add }' \
                            "${tracing_record}" \
                            "${target_file}" \
                > "${tracing_record}.tmp" && \
                mv -f "${tracing_record}.tmp" "${tracing_record}";
          else  cp -f "${target_file}" "${tracing_record}";  ## First write
        fi;
      fi;

      ## Log the generation of the JSON file
      {
        message "Generated Config-File: ${target_file}";
        # print_file "${target_file}";
      } >> "${targets_logfile}";

    fi;

    return 0;
}; alias generate-configslist='generate_configslist';

#------------------------------------------------------------------------------#
